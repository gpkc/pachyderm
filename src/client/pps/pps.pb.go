// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: client/pps/pps.proto

package pps

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	pfs "github.com/pachyderm/pachyderm/src/client/pfs"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type JobState int32

const (
	JobState_JOB_STARTING JobState = 0
	JobState_JOB_RUNNING  JobState = 1
	JobState_JOB_FAILURE  JobState = 2
	JobState_JOB_SUCCESS  JobState = 3
	JobState_JOB_KILLED   JobState = 4
	JobState_JOB_MERGING  JobState = 5
)

var JobState_name = map[int32]string{
	0: "JOB_STARTING",
	1: "JOB_RUNNING",
	2: "JOB_FAILURE",
	3: "JOB_SUCCESS",
	4: "JOB_KILLED",
	5: "JOB_MERGING",
}

var JobState_value = map[string]int32{
	"JOB_STARTING": 0,
	"JOB_RUNNING":  1,
	"JOB_FAILURE":  2,
	"JOB_SUCCESS":  3,
	"JOB_KILLED":   4,
	"JOB_MERGING":  5,
}

func (x JobState) String() string {
	return proto.EnumName(JobState_name, int32(x))
}

func (JobState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{0}
}

type DatumState int32

const (
	DatumState_FAILED    DatumState = 0
	DatumState_SUCCESS   DatumState = 1
	DatumState_SKIPPED   DatumState = 2
	DatumState_STARTING  DatumState = 3
	DatumState_RECOVERED DatumState = 4
)

var DatumState_name = map[int32]string{
	0: "FAILED",
	1: "SUCCESS",
	2: "SKIPPED",
	3: "STARTING",
	4: "RECOVERED",
}

var DatumState_value = map[string]int32{
	"FAILED":    0,
	"SUCCESS":   1,
	"SKIPPED":   2,
	"STARTING":  3,
	"RECOVERED": 4,
}

func (x DatumState) String() string {
	return proto.EnumName(DatumState_name, int32(x))
}

func (DatumState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{1}
}

type WorkerState int32

const (
	WorkerState_POD_RUNNING WorkerState = 0
	WorkerState_POD_SUCCESS WorkerState = 1
	WorkerState_POD_FAILED  WorkerState = 2
)

var WorkerState_name = map[int32]string{
	0: "POD_RUNNING",
	1: "POD_SUCCESS",
	2: "POD_FAILED",
}

var WorkerState_value = map[string]int32{
	"POD_RUNNING": 0,
	"POD_SUCCESS": 1,
	"POD_FAILED":  2,
}

func (x WorkerState) String() string {
	return proto.EnumName(WorkerState_name, int32(x))
}

func (WorkerState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{2}
}

type PipelineState int32

const (
	// When the pipeline is not ready to be triggered by commits.
	// This happens when either 1) a pipeline has been created but not
	// yet picked up by a PPS server, or 2) the pipeline does not have
	// any inputs and is meant to be triggered manually
	PipelineState_PIPELINE_STARTING PipelineState = 0
	// After this pipeline is picked up by a pachd node.  This is the normal
	// state of a pipeline.
	PipelineState_PIPELINE_RUNNING PipelineState = 1
	// After some error caused runPipeline to exit, but before the
	// pipeline is re-run.  This is when the exponential backoff is
	// in effect.
	PipelineState_PIPELINE_RESTARTING PipelineState = 2
	// We have retried too many times and we have given up on this pipeline.
	PipelineState_PIPELINE_FAILURE PipelineState = 3
	// The pipeline has been explicitly paused by the user.
	PipelineState_PIPELINE_PAUSED PipelineState = 4
	// The pipeline is fully functional, but there are no commits to process.
	PipelineState_PIPELINE_STANDBY PipelineState = 5
)

var PipelineState_name = map[int32]string{
	0: "PIPELINE_STARTING",
	1: "PIPELINE_RUNNING",
	2: "PIPELINE_RESTARTING",
	3: "PIPELINE_FAILURE",
	4: "PIPELINE_PAUSED",
	5: "PIPELINE_STANDBY",
}

var PipelineState_value = map[string]int32{
	"PIPELINE_STARTING":   0,
	"PIPELINE_RUNNING":    1,
	"PIPELINE_RESTARTING": 2,
	"PIPELINE_FAILURE":    3,
	"PIPELINE_PAUSED":     4,
	"PIPELINE_STANDBY":    5,
}

func (x PipelineState) String() string {
	return proto.EnumName(PipelineState_name, int32(x))
}

func (PipelineState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{3}
}

type Secret struct {
	// Name must be the name of the secret in kubernetes.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Key of the secret to load into env_var, this field only has meaning if EnvVar != "".
	Key                  string   `protobuf:"bytes,4,opt,name=key,proto3" json:"key,omitempty"`
	MountPath            string   `protobuf:"bytes,2,opt,name=mount_path,json=mountPath,proto3" json:"mount_path,omitempty"`
	EnvVar               string   `protobuf:"bytes,3,opt,name=env_var,json=envVar,proto3" json:"env_var,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Secret) Reset()         { *m = Secret{} }
func (m *Secret) String() string { return proto.CompactTextString(m) }
func (*Secret) ProtoMessage()    {}
func (*Secret) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{0}
}
func (m *Secret) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Secret) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Secret.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Secret) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Secret.Merge(m, src)
}
func (m *Secret) XXX_Size() int {
	return m.Size()
}
func (m *Secret) XXX_DiscardUnknown() {
	xxx_messageInfo_Secret.DiscardUnknown(m)
}

var xxx_messageInfo_Secret proto.InternalMessageInfo

func (m *Secret) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Secret) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Secret) GetMountPath() string {
	if m != nil {
		return m.MountPath
	}
	return ""
}

func (m *Secret) GetEnvVar() string {
	if m != nil {
		return m.EnvVar
	}
	return ""
}

type Transform struct {
	Image                string            `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
	Cmd                  []string          `protobuf:"bytes,2,rep,name=cmd,proto3" json:"cmd,omitempty"`
	ErrCmd               []string          `protobuf:"bytes,13,rep,name=err_cmd,json=errCmd,proto3" json:"err_cmd,omitempty"`
	Env                  map[string]string `protobuf:"bytes,3,rep,name=env,proto3" json:"env,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Secrets              []*Secret         `protobuf:"bytes,4,rep,name=secrets,proto3" json:"secrets,omitempty"`
	ImagePullSecrets     []string          `protobuf:"bytes,9,rep,name=image_pull_secrets,json=imagePullSecrets,proto3" json:"image_pull_secrets,omitempty"`
	Stdin                []string          `protobuf:"bytes,5,rep,name=stdin,proto3" json:"stdin,omitempty"`
	ErrStdin             []string          `protobuf:"bytes,14,rep,name=err_stdin,json=errStdin,proto3" json:"err_stdin,omitempty"`
	AcceptReturnCode     []int64           `protobuf:"varint,6,rep,packed,name=accept_return_code,json=acceptReturnCode,proto3" json:"accept_return_code,omitempty"`
	Debug                bool              `protobuf:"varint,7,opt,name=debug,proto3" json:"debug,omitempty"`
	User                 string            `protobuf:"bytes,10,opt,name=user,proto3" json:"user,omitempty"`
	WorkingDir           string            `protobuf:"bytes,11,opt,name=working_dir,json=workingDir,proto3" json:"working_dir,omitempty"`
	Dockerfile           string            `protobuf:"bytes,12,opt,name=dockerfile,proto3" json:"dockerfile,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Transform) Reset()         { *m = Transform{} }
func (m *Transform) String() string { return proto.CompactTextString(m) }
func (*Transform) ProtoMessage()    {}
func (*Transform) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{1}
}
func (m *Transform) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Transform) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Transform.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Transform) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transform.Merge(m, src)
}
func (m *Transform) XXX_Size() int {
	return m.Size()
}
func (m *Transform) XXX_DiscardUnknown() {
	xxx_messageInfo_Transform.DiscardUnknown(m)
}

var xxx_messageInfo_Transform proto.InternalMessageInfo

func (m *Transform) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *Transform) GetCmd() []string {
	if m != nil {
		return m.Cmd
	}
	return nil
}

func (m *Transform) GetErrCmd() []string {
	if m != nil {
		return m.ErrCmd
	}
	return nil
}

func (m *Transform) GetEnv() map[string]string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *Transform) GetSecrets() []*Secret {
	if m != nil {
		return m.Secrets
	}
	return nil
}

func (m *Transform) GetImagePullSecrets() []string {
	if m != nil {
		return m.ImagePullSecrets
	}
	return nil
}

func (m *Transform) GetStdin() []string {
	if m != nil {
		return m.Stdin
	}
	return nil
}

func (m *Transform) GetErrStdin() []string {
	if m != nil {
		return m.ErrStdin
	}
	return nil
}

func (m *Transform) GetAcceptReturnCode() []int64 {
	if m != nil {
		return m.AcceptReturnCode
	}
	return nil
}

func (m *Transform) GetDebug() bool {
	if m != nil {
		return m.Debug
	}
	return false
}

func (m *Transform) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *Transform) GetWorkingDir() string {
	if m != nil {
		return m.WorkingDir
	}
	return ""
}

func (m *Transform) GetDockerfile() string {
	if m != nil {
		return m.Dockerfile
	}
	return ""
}

type Egress struct {
	URL                  string   `protobuf:"bytes,1,opt,name=URL,proto3" json:"URL,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Egress) Reset()         { *m = Egress{} }
func (m *Egress) String() string { return proto.CompactTextString(m) }
func (*Egress) ProtoMessage()    {}
func (*Egress) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{2}
}
func (m *Egress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Egress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Egress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Egress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Egress.Merge(m, src)
}
func (m *Egress) XXX_Size() int {
	return m.Size()
}
func (m *Egress) XXX_DiscardUnknown() {
	xxx_messageInfo_Egress.DiscardUnknown(m)
}

var xxx_messageInfo_Egress proto.InternalMessageInfo

func (m *Egress) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

type Job struct {
	ID                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Job) Reset()         { *m = Job{} }
func (m *Job) String() string { return proto.CompactTextString(m) }
func (*Job) ProtoMessage()    {}
func (*Job) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{3}
}
func (m *Job) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Job) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Job.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Job) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Job.Merge(m, src)
}
func (m *Job) XXX_Size() int {
	return m.Size()
}
func (m *Job) XXX_DiscardUnknown() {
	xxx_messageInfo_Job.DiscardUnknown(m)
}

var xxx_messageInfo_Job proto.InternalMessageInfo

func (m *Job) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

type Service struct {
	InternalPort         int32    `protobuf:"varint,1,opt,name=internal_port,json=internalPort,proto3" json:"internal_port,omitempty"`
	ExternalPort         int32    `protobuf:"varint,2,opt,name=external_port,json=externalPort,proto3" json:"external_port,omitempty"`
	IP                   string   `protobuf:"bytes,3,opt,name=ip,proto3" json:"ip,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Service) Reset()         { *m = Service{} }
func (m *Service) String() string { return proto.CompactTextString(m) }
func (*Service) ProtoMessage()    {}
func (*Service) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{4}
}
func (m *Service) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Service) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Service.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Service) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Service.Merge(m, src)
}
func (m *Service) XXX_Size() int {
	return m.Size()
}
func (m *Service) XXX_DiscardUnknown() {
	xxx_messageInfo_Service.DiscardUnknown(m)
}

var xxx_messageInfo_Service proto.InternalMessageInfo

func (m *Service) GetInternalPort() int32 {
	if m != nil {
		return m.InternalPort
	}
	return 0
}

func (m *Service) GetExternalPort() int32 {
	if m != nil {
		return m.ExternalPort
	}
	return 0
}

func (m *Service) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

type Spout struct {
	Overwrite            bool     `protobuf:"varint,1,opt,name=overwrite,proto3" json:"overwrite,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Spout) Reset()         { *m = Spout{} }
func (m *Spout) String() string { return proto.CompactTextString(m) }
func (*Spout) ProtoMessage()    {}
func (*Spout) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{5}
}
func (m *Spout) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Spout) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Spout.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Spout) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Spout.Merge(m, src)
}
func (m *Spout) XXX_Size() int {
	return m.Size()
}
func (m *Spout) XXX_DiscardUnknown() {
	xxx_messageInfo_Spout.DiscardUnknown(m)
}

var xxx_messageInfo_Spout proto.InternalMessageInfo

func (m *Spout) GetOverwrite() bool {
	if m != nil {
		return m.Overwrite
	}
	return false
}

// Note: this is deprecated and replaced by `PfsInput`
type AtomInput struct {
	Name   string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Repo   string `protobuf:"bytes,2,opt,name=repo,proto3" json:"repo,omitempty"`
	Branch string `protobuf:"bytes,3,opt,name=branch,proto3" json:"branch,omitempty"`
	Commit string `protobuf:"bytes,4,opt,name=commit,proto3" json:"commit,omitempty"`
	Glob   string `protobuf:"bytes,5,opt,name=glob,proto3" json:"glob,omitempty"`
	Lazy   bool   `protobuf:"varint,6,opt,name=lazy,proto3" json:"lazy,omitempty"`
	// EmptyFiles, if true, will cause files from this atom to be presented as
	// empty files. This is useful in shuffle pipelines where you want to read
	// the names of files and reorganize them using symlinks.
	EmptyFiles           bool     `protobuf:"varint,8,opt,name=empty_files,json=emptyFiles,proto3" json:"empty_files,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AtomInput) Reset()         { *m = AtomInput{} }
func (m *AtomInput) String() string { return proto.CompactTextString(m) }
func (*AtomInput) ProtoMessage()    {}
func (*AtomInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{6}
}
func (m *AtomInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AtomInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AtomInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AtomInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AtomInput.Merge(m, src)
}
func (m *AtomInput) XXX_Size() int {
	return m.Size()
}
func (m *AtomInput) XXX_DiscardUnknown() {
	xxx_messageInfo_AtomInput.DiscardUnknown(m)
}

var xxx_messageInfo_AtomInput proto.InternalMessageInfo

func (m *AtomInput) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AtomInput) GetRepo() string {
	if m != nil {
		return m.Repo
	}
	return ""
}

func (m *AtomInput) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *AtomInput) GetCommit() string {
	if m != nil {
		return m.Commit
	}
	return ""
}

func (m *AtomInput) GetGlob() string {
	if m != nil {
		return m.Glob
	}
	return ""
}

func (m *AtomInput) GetLazy() bool {
	if m != nil {
		return m.Lazy
	}
	return false
}

func (m *AtomInput) GetEmptyFiles() bool {
	if m != nil {
		return m.EmptyFiles
	}
	return false
}

type PFSInput struct {
	Name   string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Repo   string `protobuf:"bytes,2,opt,name=repo,proto3" json:"repo,omitempty"`
	Branch string `protobuf:"bytes,3,opt,name=branch,proto3" json:"branch,omitempty"`
	Commit string `protobuf:"bytes,4,opt,name=commit,proto3" json:"commit,omitempty"`
	Glob   string `protobuf:"bytes,5,opt,name=glob,proto3" json:"glob,omitempty"`
	Lazy   bool   `protobuf:"varint,6,opt,name=lazy,proto3" json:"lazy,omitempty"`
	// EmptyFiles, if true, will cause files from this PFS input to be
	// presented as empty files. This is useful in shuffle pipelines where you
	// want to read the names of files and reorganize them using symlinks.
	EmptyFiles           bool     `protobuf:"varint,7,opt,name=empty_files,json=emptyFiles,proto3" json:"empty_files,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PFSInput) Reset()         { *m = PFSInput{} }
func (m *PFSInput) String() string { return proto.CompactTextString(m) }
func (*PFSInput) ProtoMessage()    {}
func (*PFSInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{7}
}
func (m *PFSInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PFSInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PFSInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PFSInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PFSInput.Merge(m, src)
}
func (m *PFSInput) XXX_Size() int {
	return m.Size()
}
func (m *PFSInput) XXX_DiscardUnknown() {
	xxx_messageInfo_PFSInput.DiscardUnknown(m)
}

var xxx_messageInfo_PFSInput proto.InternalMessageInfo

func (m *PFSInput) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PFSInput) GetRepo() string {
	if m != nil {
		return m.Repo
	}
	return ""
}

func (m *PFSInput) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *PFSInput) GetCommit() string {
	if m != nil {
		return m.Commit
	}
	return ""
}

func (m *PFSInput) GetGlob() string {
	if m != nil {
		return m.Glob
	}
	return ""
}

func (m *PFSInput) GetLazy() bool {
	if m != nil {
		return m.Lazy
	}
	return false
}

func (m *PFSInput) GetEmptyFiles() bool {
	if m != nil {
		return m.EmptyFiles
	}
	return false
}

type CronInput struct {
	Name   string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Repo   string `protobuf:"bytes,2,opt,name=repo,proto3" json:"repo,omitempty"`
	Commit string `protobuf:"bytes,3,opt,name=commit,proto3" json:"commit,omitempty"`
	Spec   string `protobuf:"bytes,4,opt,name=spec,proto3" json:"spec,omitempty"`
	// Overwrite, if true, will expose a single datum that gets overwritten each
	// tick. If false, it will create a new datum for each tick.
	Overwrite            bool             `protobuf:"varint,6,opt,name=overwrite,proto3" json:"overwrite,omitempty"`
	Start                *types.Timestamp `protobuf:"bytes,5,opt,name=start,proto3" json:"start,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *CronInput) Reset()         { *m = CronInput{} }
func (m *CronInput) String() string { return proto.CompactTextString(m) }
func (*CronInput) ProtoMessage()    {}
func (*CronInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{8}
}
func (m *CronInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CronInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CronInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CronInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CronInput.Merge(m, src)
}
func (m *CronInput) XXX_Size() int {
	return m.Size()
}
func (m *CronInput) XXX_DiscardUnknown() {
	xxx_messageInfo_CronInput.DiscardUnknown(m)
}

var xxx_messageInfo_CronInput proto.InternalMessageInfo

func (m *CronInput) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CronInput) GetRepo() string {
	if m != nil {
		return m.Repo
	}
	return ""
}

func (m *CronInput) GetCommit() string {
	if m != nil {
		return m.Commit
	}
	return ""
}

func (m *CronInput) GetSpec() string {
	if m != nil {
		return m.Spec
	}
	return ""
}

func (m *CronInput) GetOverwrite() bool {
	if m != nil {
		return m.Overwrite
	}
	return false
}

func (m *CronInput) GetStart() *types.Timestamp {
	if m != nil {
		return m.Start
	}
	return nil
}

type GitInput struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	URL                  string   `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	Branch               string   `protobuf:"bytes,3,opt,name=branch,proto3" json:"branch,omitempty"`
	Commit               string   `protobuf:"bytes,4,opt,name=commit,proto3" json:"commit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GitInput) Reset()         { *m = GitInput{} }
func (m *GitInput) String() string { return proto.CompactTextString(m) }
func (*GitInput) ProtoMessage()    {}
func (*GitInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{9}
}
func (m *GitInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GitInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GitInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GitInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GitInput.Merge(m, src)
}
func (m *GitInput) XXX_Size() int {
	return m.Size()
}
func (m *GitInput) XXX_DiscardUnknown() {
	xxx_messageInfo_GitInput.DiscardUnknown(m)
}

var xxx_messageInfo_GitInput proto.InternalMessageInfo

func (m *GitInput) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GitInput) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

func (m *GitInput) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *GitInput) GetCommit() string {
	if m != nil {
		return m.Commit
	}
	return ""
}

type Input struct {
	// Note: this is deprecated and replaced by `PfsInput`
	Atom                 *AtomInput `protobuf:"bytes,1,opt,name=atom,proto3" json:"atom,omitempty"`
	Pfs                  *PFSInput  `protobuf:"bytes,6,opt,name=pfs,proto3" json:"pfs,omitempty"`
	Cross                []*Input   `protobuf:"bytes,2,rep,name=cross,proto3" json:"cross,omitempty"`
	Union                []*Input   `protobuf:"bytes,3,rep,name=union,proto3" json:"union,omitempty"`
	Cron                 *CronInput `protobuf:"bytes,4,opt,name=cron,proto3" json:"cron,omitempty"`
	Git                  *GitInput  `protobuf:"bytes,5,opt,name=git,proto3" json:"git,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Input) Reset()         { *m = Input{} }
func (m *Input) String() string { return proto.CompactTextString(m) }
func (*Input) ProtoMessage()    {}
func (*Input) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{10}
}
func (m *Input) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Input) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Input.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Input) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Input.Merge(m, src)
}
func (m *Input) XXX_Size() int {
	return m.Size()
}
func (m *Input) XXX_DiscardUnknown() {
	xxx_messageInfo_Input.DiscardUnknown(m)
}

var xxx_messageInfo_Input proto.InternalMessageInfo

func (m *Input) GetAtom() *AtomInput {
	if m != nil {
		return m.Atom
	}
	return nil
}

func (m *Input) GetPfs() *PFSInput {
	if m != nil {
		return m.Pfs
	}
	return nil
}

func (m *Input) GetCross() []*Input {
	if m != nil {
		return m.Cross
	}
	return nil
}

func (m *Input) GetUnion() []*Input {
	if m != nil {
		return m.Union
	}
	return nil
}

func (m *Input) GetCron() *CronInput {
	if m != nil {
		return m.Cron
	}
	return nil
}

func (m *Input) GetGit() *GitInput {
	if m != nil {
		return m.Git
	}
	return nil
}

type JobInput struct {
	Name                 string      `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	Commit               *pfs.Commit `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	Glob                 string      `protobuf:"bytes,2,opt,name=glob,proto3" json:"glob,omitempty"`
	Lazy                 bool        `protobuf:"varint,3,opt,name=lazy,proto3" json:"lazy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *JobInput) Reset()         { *m = JobInput{} }
func (m *JobInput) String() string { return proto.CompactTextString(m) }
func (*JobInput) ProtoMessage()    {}
func (*JobInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{11}
}
func (m *JobInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobInput.Merge(m, src)
}
func (m *JobInput) XXX_Size() int {
	return m.Size()
}
func (m *JobInput) XXX_DiscardUnknown() {
	xxx_messageInfo_JobInput.DiscardUnknown(m)
}

var xxx_messageInfo_JobInput proto.InternalMessageInfo

func (m *JobInput) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *JobInput) GetCommit() *pfs.Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *JobInput) GetGlob() string {
	if m != nil {
		return m.Glob
	}
	return ""
}

func (m *JobInput) GetLazy() bool {
	if m != nil {
		return m.Lazy
	}
	return false
}

type ParallelismSpec struct {
	// Starts the pipeline/job with a 'constant' workers, unless 'constant' is
	// zero. If 'constant' is zero (which is the zero value of ParallelismSpec),
	// then Pachyderm will choose the number of workers that is started,
	// (currently it chooses the number of workers in the cluster)
	Constant uint64 `protobuf:"varint,2,opt,name=constant,proto3" json:"constant,omitempty"`
	// Starts the pipeline/job with number of workers equal to 'coefficient' * N,
	// where N is the number of nodes in the kubernetes cluster.
	//
	// For example, if each Kubernetes node has four CPUs, you might set
	// 'coefficient' to four, so that there are four Pachyderm workers per
	// Kubernetes node, and each Pachyderm worker gets one CPU. If you want to
	// reserve half the nodes in your cluster for other tasks, you might set
	// 'coefficient' to 0.5.
	Coefficient          float64  `protobuf:"fixed64,3,opt,name=coefficient,proto3" json:"coefficient,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ParallelismSpec) Reset()         { *m = ParallelismSpec{} }
func (m *ParallelismSpec) String() string { return proto.CompactTextString(m) }
func (*ParallelismSpec) ProtoMessage()    {}
func (*ParallelismSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{12}
}
func (m *ParallelismSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParallelismSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParallelismSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParallelismSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParallelismSpec.Merge(m, src)
}
func (m *ParallelismSpec) XXX_Size() int {
	return m.Size()
}
func (m *ParallelismSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ParallelismSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ParallelismSpec proto.InternalMessageInfo

func (m *ParallelismSpec) GetConstant() uint64 {
	if m != nil {
		return m.Constant
	}
	return 0
}

func (m *ParallelismSpec) GetCoefficient() float64 {
	if m != nil {
		return m.Coefficient
	}
	return 0
}

// HashTreeSpec sets the number of shards into which pps splits a pipeline's
// output commits (sharded commits are implemented in Pachyderm 1.8+ only)
type HashtreeSpec struct {
	Constant             uint64   `protobuf:"varint,1,opt,name=constant,proto3" json:"constant,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HashtreeSpec) Reset()         { *m = HashtreeSpec{} }
func (m *HashtreeSpec) String() string { return proto.CompactTextString(m) }
func (*HashtreeSpec) ProtoMessage()    {}
func (*HashtreeSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{13}
}
func (m *HashtreeSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HashtreeSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HashtreeSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HashtreeSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HashtreeSpec.Merge(m, src)
}
func (m *HashtreeSpec) XXX_Size() int {
	return m.Size()
}
func (m *HashtreeSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_HashtreeSpec.DiscardUnknown(m)
}

var xxx_messageInfo_HashtreeSpec proto.InternalMessageInfo

func (m *HashtreeSpec) GetConstant() uint64 {
	if m != nil {
		return m.Constant
	}
	return 0
}

type InputFile struct {
	// This file's absolute path within its pfs repo.
	Path string `protobuf:"bytes,4,opt,name=path,proto3" json:"path,omitempty"`
	// This file's hash
	Hash                 []byte   `protobuf:"bytes,5,opt,name=hash,proto3" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InputFile) Reset()         { *m = InputFile{} }
func (m *InputFile) String() string { return proto.CompactTextString(m) }
func (*InputFile) ProtoMessage()    {}
func (*InputFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{14}
}
func (m *InputFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputFile.Merge(m, src)
}
func (m *InputFile) XXX_Size() int {
	return m.Size()
}
func (m *InputFile) XXX_DiscardUnknown() {
	xxx_messageInfo_InputFile.DiscardUnknown(m)
}

var xxx_messageInfo_InputFile proto.InternalMessageInfo

func (m *InputFile) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *InputFile) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

type Datum struct {
	// ID is the hash computed from all the files
	ID                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Job                  *Job     `protobuf:"bytes,2,opt,name=job,proto3" json:"job,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Datum) Reset()         { *m = Datum{} }
func (m *Datum) String() string { return proto.CompactTextString(m) }
func (*Datum) ProtoMessage()    {}
func (*Datum) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{15}
}
func (m *Datum) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Datum) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Datum.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Datum) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Datum.Merge(m, src)
}
func (m *Datum) XXX_Size() int {
	return m.Size()
}
func (m *Datum) XXX_DiscardUnknown() {
	xxx_messageInfo_Datum.DiscardUnknown(m)
}

var xxx_messageInfo_Datum proto.InternalMessageInfo

func (m *Datum) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Datum) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

type DatumInfo struct {
	Datum                *Datum          `protobuf:"bytes,1,opt,name=datum,proto3" json:"datum,omitempty"`
	State                DatumState      `protobuf:"varint,2,opt,name=state,proto3,enum=pps.DatumState" json:"state,omitempty"`
	Stats                *ProcessStats   `protobuf:"bytes,3,opt,name=stats,proto3" json:"stats,omitempty"`
	PfsState             *pfs.File       `protobuf:"bytes,4,opt,name=pfs_state,json=pfsState,proto3" json:"pfs_state,omitempty"`
	Data                 []*pfs.FileInfo `protobuf:"bytes,5,rep,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *DatumInfo) Reset()         { *m = DatumInfo{} }
func (m *DatumInfo) String() string { return proto.CompactTextString(m) }
func (*DatumInfo) ProtoMessage()    {}
func (*DatumInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{16}
}
func (m *DatumInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatumInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatumInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatumInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatumInfo.Merge(m, src)
}
func (m *DatumInfo) XXX_Size() int {
	return m.Size()
}
func (m *DatumInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DatumInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DatumInfo proto.InternalMessageInfo

func (m *DatumInfo) GetDatum() *Datum {
	if m != nil {
		return m.Datum
	}
	return nil
}

func (m *DatumInfo) GetState() DatumState {
	if m != nil {
		return m.State
	}
	return DatumState_FAILED
}

func (m *DatumInfo) GetStats() *ProcessStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *DatumInfo) GetPfsState() *pfs.File {
	if m != nil {
		return m.PfsState
	}
	return nil
}

func (m *DatumInfo) GetData() []*pfs.FileInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type Aggregate struct {
	Count                 int64    `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	Mean                  float64  `protobuf:"fixed64,2,opt,name=mean,proto3" json:"mean,omitempty"`
	Stddev                float64  `protobuf:"fixed64,3,opt,name=stddev,proto3" json:"stddev,omitempty"`
	FifthPercentile       float64  `protobuf:"fixed64,4,opt,name=fifth_percentile,json=fifthPercentile,proto3" json:"fifth_percentile,omitempty"`
	NinetyFifthPercentile float64  `protobuf:"fixed64,5,opt,name=ninety_fifth_percentile,json=ninetyFifthPercentile,proto3" json:"ninety_fifth_percentile,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *Aggregate) Reset()         { *m = Aggregate{} }
func (m *Aggregate) String() string { return proto.CompactTextString(m) }
func (*Aggregate) ProtoMessage()    {}
func (*Aggregate) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{17}
}
func (m *Aggregate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Aggregate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Aggregate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Aggregate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Aggregate.Merge(m, src)
}
func (m *Aggregate) XXX_Size() int {
	return m.Size()
}
func (m *Aggregate) XXX_DiscardUnknown() {
	xxx_messageInfo_Aggregate.DiscardUnknown(m)
}

var xxx_messageInfo_Aggregate proto.InternalMessageInfo

func (m *Aggregate) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Aggregate) GetMean() float64 {
	if m != nil {
		return m.Mean
	}
	return 0
}

func (m *Aggregate) GetStddev() float64 {
	if m != nil {
		return m.Stddev
	}
	return 0
}

func (m *Aggregate) GetFifthPercentile() float64 {
	if m != nil {
		return m.FifthPercentile
	}
	return 0
}

func (m *Aggregate) GetNinetyFifthPercentile() float64 {
	if m != nil {
		return m.NinetyFifthPercentile
	}
	return 0
}

type ProcessStats struct {
	DownloadTime         *types.Duration `protobuf:"bytes,1,opt,name=download_time,json=downloadTime,proto3" json:"download_time,omitempty"`
	ProcessTime          *types.Duration `protobuf:"bytes,2,opt,name=process_time,json=processTime,proto3" json:"process_time,omitempty"`
	UploadTime           *types.Duration `protobuf:"bytes,3,opt,name=upload_time,json=uploadTime,proto3" json:"upload_time,omitempty"`
	DownloadBytes        uint64          `protobuf:"varint,4,opt,name=download_bytes,json=downloadBytes,proto3" json:"download_bytes,omitempty"`
	UploadBytes          uint64          `protobuf:"varint,5,opt,name=upload_bytes,json=uploadBytes,proto3" json:"upload_bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ProcessStats) Reset()         { *m = ProcessStats{} }
func (m *ProcessStats) String() string { return proto.CompactTextString(m) }
func (*ProcessStats) ProtoMessage()    {}
func (*ProcessStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{18}
}
func (m *ProcessStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessStats.Merge(m, src)
}
func (m *ProcessStats) XXX_Size() int {
	return m.Size()
}
func (m *ProcessStats) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessStats.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessStats proto.InternalMessageInfo

func (m *ProcessStats) GetDownloadTime() *types.Duration {
	if m != nil {
		return m.DownloadTime
	}
	return nil
}

func (m *ProcessStats) GetProcessTime() *types.Duration {
	if m != nil {
		return m.ProcessTime
	}
	return nil
}

func (m *ProcessStats) GetUploadTime() *types.Duration {
	if m != nil {
		return m.UploadTime
	}
	return nil
}

func (m *ProcessStats) GetDownloadBytes() uint64 {
	if m != nil {
		return m.DownloadBytes
	}
	return 0
}

func (m *ProcessStats) GetUploadBytes() uint64 {
	if m != nil {
		return m.UploadBytes
	}
	return 0
}

type AggregateProcessStats struct {
	DownloadTime         *Aggregate `protobuf:"bytes,1,opt,name=download_time,json=downloadTime,proto3" json:"download_time,omitempty"`
	ProcessTime          *Aggregate `protobuf:"bytes,2,opt,name=process_time,json=processTime,proto3" json:"process_time,omitempty"`
	UploadTime           *Aggregate `protobuf:"bytes,3,opt,name=upload_time,json=uploadTime,proto3" json:"upload_time,omitempty"`
	DownloadBytes        *Aggregate `protobuf:"bytes,4,opt,name=download_bytes,json=downloadBytes,proto3" json:"download_bytes,omitempty"`
	UploadBytes          *Aggregate `protobuf:"bytes,5,opt,name=upload_bytes,json=uploadBytes,proto3" json:"upload_bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *AggregateProcessStats) Reset()         { *m = AggregateProcessStats{} }
func (m *AggregateProcessStats) String() string { return proto.CompactTextString(m) }
func (*AggregateProcessStats) ProtoMessage()    {}
func (*AggregateProcessStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{19}
}
func (m *AggregateProcessStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AggregateProcessStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AggregateProcessStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AggregateProcessStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AggregateProcessStats.Merge(m, src)
}
func (m *AggregateProcessStats) XXX_Size() int {
	return m.Size()
}
func (m *AggregateProcessStats) XXX_DiscardUnknown() {
	xxx_messageInfo_AggregateProcessStats.DiscardUnknown(m)
}

var xxx_messageInfo_AggregateProcessStats proto.InternalMessageInfo

func (m *AggregateProcessStats) GetDownloadTime() *Aggregate {
	if m != nil {
		return m.DownloadTime
	}
	return nil
}

func (m *AggregateProcessStats) GetProcessTime() *Aggregate {
	if m != nil {
		return m.ProcessTime
	}
	return nil
}

func (m *AggregateProcessStats) GetUploadTime() *Aggregate {
	if m != nil {
		return m.UploadTime
	}
	return nil
}

func (m *AggregateProcessStats) GetDownloadBytes() *Aggregate {
	if m != nil {
		return m.DownloadBytes
	}
	return nil
}

func (m *AggregateProcessStats) GetUploadBytes() *Aggregate {
	if m != nil {
		return m.UploadBytes
	}
	return nil
}

type WorkerStatus struct {
	WorkerID string       `protobuf:"bytes,1,opt,name=worker_id,json=workerId,proto3" json:"worker_id,omitempty"`
	JobID    string       `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	Data     []*InputFile `protobuf:"bytes,3,rep,name=data,proto3" json:"data,omitempty"`
	// Started is the time processing on the current datum began.
	Started              *types.Timestamp `protobuf:"bytes,4,opt,name=started,proto3" json:"started,omitempty"`
	Stats                *ProcessStats    `protobuf:"bytes,5,opt,name=stats,proto3" json:"stats,omitempty"`
	QueueSize            int64            `protobuf:"varint,6,opt,name=queue_size,json=queueSize,proto3" json:"queue_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *WorkerStatus) Reset()         { *m = WorkerStatus{} }
func (m *WorkerStatus) String() string { return proto.CompactTextString(m) }
func (*WorkerStatus) ProtoMessage()    {}
func (*WorkerStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{20}
}
func (m *WorkerStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkerStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkerStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerStatus.Merge(m, src)
}
func (m *WorkerStatus) XXX_Size() int {
	return m.Size()
}
func (m *WorkerStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerStatus.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerStatus proto.InternalMessageInfo

func (m *WorkerStatus) GetWorkerID() string {
	if m != nil {
		return m.WorkerID
	}
	return ""
}

func (m *WorkerStatus) GetJobID() string {
	if m != nil {
		return m.JobID
	}
	return ""
}

func (m *WorkerStatus) GetData() []*InputFile {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *WorkerStatus) GetStarted() *types.Timestamp {
	if m != nil {
		return m.Started
	}
	return nil
}

func (m *WorkerStatus) GetStats() *ProcessStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *WorkerStatus) GetQueueSize() int64 {
	if m != nil {
		return m.QueueSize
	}
	return 0
}

// ResourceSpec describes the amount of resources that pipeline pods should
// request from kubernetes, for scheduling.
type ResourceSpec struct {
	// The number of CPUs each worker needs (partial values are allowed, and
	// encouraged)
	Cpu float32 `protobuf:"fixed32,1,opt,name=cpu,proto3" json:"cpu,omitempty"`
	// The amount of memory each worker needs (in bytes, with allowed
	// SI suffixes (M, K, G, Mi, Ki, Gi, etc).
	Memory string `protobuf:"bytes,2,opt,name=memory,proto3" json:"memory,omitempty"`
	// The spec for GPU resources.
	Gpu *GPUSpec `protobuf:"bytes,5,opt,name=gpu,proto3" json:"gpu,omitempty"`
	// The amount of ephemeral storage each worker needs (in bytes, with allowed
	// SI suffixes (M, K, G, Mi, Ki, Gi, etc).
	Disk                 string   `protobuf:"bytes,4,opt,name=disk,proto3" json:"disk,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResourceSpec) Reset()         { *m = ResourceSpec{} }
func (m *ResourceSpec) String() string { return proto.CompactTextString(m) }
func (*ResourceSpec) ProtoMessage()    {}
func (*ResourceSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{21}
}
func (m *ResourceSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceSpec.Merge(m, src)
}
func (m *ResourceSpec) XXX_Size() int {
	return m.Size()
}
func (m *ResourceSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceSpec proto.InternalMessageInfo

func (m *ResourceSpec) GetCpu() float32 {
	if m != nil {
		return m.Cpu
	}
	return 0
}

func (m *ResourceSpec) GetMemory() string {
	if m != nil {
		return m.Memory
	}
	return ""
}

func (m *ResourceSpec) GetGpu() *GPUSpec {
	if m != nil {
		return m.Gpu
	}
	return nil
}

func (m *ResourceSpec) GetDisk() string {
	if m != nil {
		return m.Disk
	}
	return ""
}

type GPUSpec struct {
	// The type of GPU (nvidia.com/gpu or amd.com/gpu for example).
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// The number of GPUs to request.
	Number               int64    `protobuf:"varint,2,opt,name=number,proto3" json:"number,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GPUSpec) Reset()         { *m = GPUSpec{} }
func (m *GPUSpec) String() string { return proto.CompactTextString(m) }
func (*GPUSpec) ProtoMessage()    {}
func (*GPUSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{22}
}
func (m *GPUSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GPUSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GPUSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GPUSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GPUSpec.Merge(m, src)
}
func (m *GPUSpec) XXX_Size() int {
	return m.Size()
}
func (m *GPUSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_GPUSpec.DiscardUnknown(m)
}

var xxx_messageInfo_GPUSpec proto.InternalMessageInfo

func (m *GPUSpec) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *GPUSpec) GetNumber() int64 {
	if m != nil {
		return m.Number
	}
	return 0
}

// EtcdJobInfo is the portion of the JobInfo that gets stored in etcd during
// job execution. It contains fields which change over the lifetime of the job
// but aren't used in the execution of the job.
type EtcdJobInfo struct {
	Job          *Job        `protobuf:"bytes,1,opt,name=job,proto3" json:"job,omitempty"`
	Pipeline     *Pipeline   `protobuf:"bytes,2,opt,name=pipeline,proto3" json:"pipeline,omitempty"`
	OutputCommit *pfs.Commit `protobuf:"bytes,3,opt,name=output_commit,json=outputCommit,proto3" json:"output_commit,omitempty"`
	// Job restart count (e.g. due to datum failure)
	Restart uint64 `protobuf:"varint,4,opt,name=restart,proto3" json:"restart,omitempty"`
	// Counts of how many times we processed or skipped a datum
	DataProcessed int64 `protobuf:"varint,5,opt,name=data_processed,json=dataProcessed,proto3" json:"data_processed,omitempty"`
	DataSkipped   int64 `protobuf:"varint,6,opt,name=data_skipped,json=dataSkipped,proto3" json:"data_skipped,omitempty"`
	DataTotal     int64 `protobuf:"varint,7,opt,name=data_total,json=dataTotal,proto3" json:"data_total,omitempty"`
	DataFailed    int64 `protobuf:"varint,8,opt,name=data_failed,json=dataFailed,proto3" json:"data_failed,omitempty"`
	DataRecovered int64 `protobuf:"varint,15,opt,name=data_recovered,json=dataRecovered,proto3" json:"data_recovered,omitempty"`
	// Download/process/upload time and download/upload bytes
	Stats                *ProcessStats    `protobuf:"bytes,9,opt,name=stats,proto3" json:"stats,omitempty"`
	StatsCommit          *pfs.Commit      `protobuf:"bytes,10,opt,name=stats_commit,json=statsCommit,proto3" json:"stats_commit,omitempty"`
	State                JobState         `protobuf:"varint,11,opt,name=state,proto3,enum=pps.JobState" json:"state,omitempty"`
	Reason               string           `protobuf:"bytes,12,opt,name=reason,proto3" json:"reason,omitempty"`
	Started              *types.Timestamp `protobuf:"bytes,13,opt,name=started,proto3" json:"started,omitempty"`
	Finished             *types.Timestamp `protobuf:"bytes,14,opt,name=finished,proto3" json:"finished,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *EtcdJobInfo) Reset()         { *m = EtcdJobInfo{} }
func (m *EtcdJobInfo) String() string { return proto.CompactTextString(m) }
func (*EtcdJobInfo) ProtoMessage()    {}
func (*EtcdJobInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{23}
}
func (m *EtcdJobInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EtcdJobInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EtcdJobInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EtcdJobInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EtcdJobInfo.Merge(m, src)
}
func (m *EtcdJobInfo) XXX_Size() int {
	return m.Size()
}
func (m *EtcdJobInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_EtcdJobInfo.DiscardUnknown(m)
}

var xxx_messageInfo_EtcdJobInfo proto.InternalMessageInfo

func (m *EtcdJobInfo) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

func (m *EtcdJobInfo) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *EtcdJobInfo) GetOutputCommit() *pfs.Commit {
	if m != nil {
		return m.OutputCommit
	}
	return nil
}

func (m *EtcdJobInfo) GetRestart() uint64 {
	if m != nil {
		return m.Restart
	}
	return 0
}

func (m *EtcdJobInfo) GetDataProcessed() int64 {
	if m != nil {
		return m.DataProcessed
	}
	return 0
}

func (m *EtcdJobInfo) GetDataSkipped() int64 {
	if m != nil {
		return m.DataSkipped
	}
	return 0
}

func (m *EtcdJobInfo) GetDataTotal() int64 {
	if m != nil {
		return m.DataTotal
	}
	return 0
}

func (m *EtcdJobInfo) GetDataFailed() int64 {
	if m != nil {
		return m.DataFailed
	}
	return 0
}

func (m *EtcdJobInfo) GetDataRecovered() int64 {
	if m != nil {
		return m.DataRecovered
	}
	return 0
}

func (m *EtcdJobInfo) GetStats() *ProcessStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *EtcdJobInfo) GetStatsCommit() *pfs.Commit {
	if m != nil {
		return m.StatsCommit
	}
	return nil
}

func (m *EtcdJobInfo) GetState() JobState {
	if m != nil {
		return m.State
	}
	return JobState_JOB_STARTING
}

func (m *EtcdJobInfo) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *EtcdJobInfo) GetStarted() *types.Timestamp {
	if m != nil {
		return m.Started
	}
	return nil
}

func (m *EtcdJobInfo) GetFinished() *types.Timestamp {
	if m != nil {
		return m.Finished
	}
	return nil
}

type JobInfo struct {
	Job                  *Job             `protobuf:"bytes,1,opt,name=job,proto3" json:"job,omitempty"`
	Transform            *Transform       `protobuf:"bytes,2,opt,name=transform,proto3" json:"transform,omitempty"`
	Pipeline             *Pipeline        `protobuf:"bytes,3,opt,name=pipeline,proto3" json:"pipeline,omitempty"`
	PipelineVersion      uint64           `protobuf:"varint,13,opt,name=pipeline_version,json=pipelineVersion,proto3" json:"pipeline_version,omitempty"`
	ParallelismSpec      *ParallelismSpec `protobuf:"bytes,12,opt,name=parallelism_spec,json=parallelismSpec,proto3" json:"parallelism_spec,omitempty"`
	Egress               *Egress          `protobuf:"bytes,15,opt,name=egress,proto3" json:"egress,omitempty"`
	ParentJob            *Job             `protobuf:"bytes,6,opt,name=parent_job,json=parentJob,proto3" json:"parent_job,omitempty"`
	Started              *types.Timestamp `protobuf:"bytes,7,opt,name=started,proto3" json:"started,omitempty"`
	Finished             *types.Timestamp `protobuf:"bytes,8,opt,name=finished,proto3" json:"finished,omitempty"`
	OutputCommit         *pfs.Commit      `protobuf:"bytes,9,opt,name=output_commit,json=outputCommit,proto3" json:"output_commit,omitempty"`
	State                JobState         `protobuf:"varint,10,opt,name=state,proto3,enum=pps.JobState" json:"state,omitempty"`
	Reason               string           `protobuf:"bytes,35,opt,name=reason,proto3" json:"reason,omitempty"`
	Service              *Service         `protobuf:"bytes,14,opt,name=service,proto3" json:"service,omitempty"`
	Spout                *Spout           `protobuf:"bytes,45,opt,name=spout,proto3" json:"spout,omitempty"`
	OutputRepo           *pfs.Repo        `protobuf:"bytes,18,opt,name=output_repo,json=outputRepo,proto3" json:"output_repo,omitempty"`
	OutputBranch         string           `protobuf:"bytes,17,opt,name=output_branch,json=outputBranch,proto3" json:"output_branch,omitempty"`
	Restart              uint64           `protobuf:"varint,20,opt,name=restart,proto3" json:"restart,omitempty"`
	DataProcessed        int64            `protobuf:"varint,22,opt,name=data_processed,json=dataProcessed,proto3" json:"data_processed,omitempty"`
	DataSkipped          int64            `protobuf:"varint,30,opt,name=data_skipped,json=dataSkipped,proto3" json:"data_skipped,omitempty"`
	DataFailed           int64            `protobuf:"varint,40,opt,name=data_failed,json=dataFailed,proto3" json:"data_failed,omitempty"`
	DataRecovered        int64            `protobuf:"varint,46,opt,name=data_recovered,json=dataRecovered,proto3" json:"data_recovered,omitempty"`
	DataTotal            int64            `protobuf:"varint,23,opt,name=data_total,json=dataTotal,proto3" json:"data_total,omitempty"`
	Stats                *ProcessStats    `protobuf:"bytes,31,opt,name=stats,proto3" json:"stats,omitempty"`
	WorkerStatus         []*WorkerStatus  `protobuf:"bytes,24,rep,name=worker_status,json=workerStatus,proto3" json:"worker_status,omitempty"`
	ResourceRequests     *ResourceSpec    `protobuf:"bytes,25,opt,name=resource_requests,json=resourceRequests,proto3" json:"resource_requests,omitempty"`
	ResourceLimits       *ResourceSpec    `protobuf:"bytes,36,opt,name=resource_limits,json=resourceLimits,proto3" json:"resource_limits,omitempty"`
	Input                *Input           `protobuf:"bytes,26,opt,name=input,proto3" json:"input,omitempty"`
	NewBranch            *pfs.BranchInfo  `protobuf:"bytes,27,opt,name=new_branch,json=newBranch,proto3" json:"new_branch,omitempty"`
	StatsCommit          *pfs.Commit      `protobuf:"bytes,29,opt,name=stats_commit,json=statsCommit,proto3" json:"stats_commit,omitempty"`
	EnableStats          bool             `protobuf:"varint,32,opt,name=enable_stats,json=enableStats,proto3" json:"enable_stats,omitempty"`
	Salt                 string           `protobuf:"bytes,33,opt,name=salt,proto3" json:"salt,omitempty"`
	Batch                bool             `protobuf:"varint,34,opt,name=batch,proto3" json:"batch,omitempty"`
	ChunkSpec            *ChunkSpec       `protobuf:"bytes,37,opt,name=chunk_spec,json=chunkSpec,proto3" json:"chunk_spec,omitempty"`
	DatumTimeout         *types.Duration  `protobuf:"bytes,38,opt,name=datum_timeout,json=datumTimeout,proto3" json:"datum_timeout,omitempty"`
	JobTimeout           *types.Duration  `protobuf:"bytes,39,opt,name=job_timeout,json=jobTimeout,proto3" json:"job_timeout,omitempty"`
	DatumTries           int64            `protobuf:"varint,41,opt,name=datum_tries,json=datumTries,proto3" json:"datum_tries,omitempty"`
	SchedulingSpec       *SchedulingSpec  `protobuf:"bytes,42,opt,name=scheduling_spec,json=schedulingSpec,proto3" json:"scheduling_spec,omitempty"`
	PodSpec              string           `protobuf:"bytes,43,opt,name=pod_spec,json=podSpec,proto3" json:"pod_spec,omitempty"`
	PodPatch             string           `protobuf:"bytes,44,opt,name=pod_patch,json=podPatch,proto3" json:"pod_patch,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *JobInfo) Reset()         { *m = JobInfo{} }
func (m *JobInfo) String() string { return proto.CompactTextString(m) }
func (*JobInfo) ProtoMessage()    {}
func (*JobInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{24}
}
func (m *JobInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobInfo.Merge(m, src)
}
func (m *JobInfo) XXX_Size() int {
	return m.Size()
}
func (m *JobInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_JobInfo.DiscardUnknown(m)
}

var xxx_messageInfo_JobInfo proto.InternalMessageInfo

func (m *JobInfo) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

func (m *JobInfo) GetTransform() *Transform {
	if m != nil {
		return m.Transform
	}
	return nil
}

func (m *JobInfo) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *JobInfo) GetPipelineVersion() uint64 {
	if m != nil {
		return m.PipelineVersion
	}
	return 0
}

func (m *JobInfo) GetParallelismSpec() *ParallelismSpec {
	if m != nil {
		return m.ParallelismSpec
	}
	return nil
}

func (m *JobInfo) GetEgress() *Egress {
	if m != nil {
		return m.Egress
	}
	return nil
}

func (m *JobInfo) GetParentJob() *Job {
	if m != nil {
		return m.ParentJob
	}
	return nil
}

func (m *JobInfo) GetStarted() *types.Timestamp {
	if m != nil {
		return m.Started
	}
	return nil
}

func (m *JobInfo) GetFinished() *types.Timestamp {
	if m != nil {
		return m.Finished
	}
	return nil
}

func (m *JobInfo) GetOutputCommit() *pfs.Commit {
	if m != nil {
		return m.OutputCommit
	}
	return nil
}

func (m *JobInfo) GetState() JobState {
	if m != nil {
		return m.State
	}
	return JobState_JOB_STARTING
}

func (m *JobInfo) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *JobInfo) GetService() *Service {
	if m != nil {
		return m.Service
	}
	return nil
}

func (m *JobInfo) GetSpout() *Spout {
	if m != nil {
		return m.Spout
	}
	return nil
}

func (m *JobInfo) GetOutputRepo() *pfs.Repo {
	if m != nil {
		return m.OutputRepo
	}
	return nil
}

func (m *JobInfo) GetOutputBranch() string {
	if m != nil {
		return m.OutputBranch
	}
	return ""
}

func (m *JobInfo) GetRestart() uint64 {
	if m != nil {
		return m.Restart
	}
	return 0
}

func (m *JobInfo) GetDataProcessed() int64 {
	if m != nil {
		return m.DataProcessed
	}
	return 0
}

func (m *JobInfo) GetDataSkipped() int64 {
	if m != nil {
		return m.DataSkipped
	}
	return 0
}

func (m *JobInfo) GetDataFailed() int64 {
	if m != nil {
		return m.DataFailed
	}
	return 0
}

func (m *JobInfo) GetDataRecovered() int64 {
	if m != nil {
		return m.DataRecovered
	}
	return 0
}

func (m *JobInfo) GetDataTotal() int64 {
	if m != nil {
		return m.DataTotal
	}
	return 0
}

func (m *JobInfo) GetStats() *ProcessStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *JobInfo) GetWorkerStatus() []*WorkerStatus {
	if m != nil {
		return m.WorkerStatus
	}
	return nil
}

func (m *JobInfo) GetResourceRequests() *ResourceSpec {
	if m != nil {
		return m.ResourceRequests
	}
	return nil
}

func (m *JobInfo) GetResourceLimits() *ResourceSpec {
	if m != nil {
		return m.ResourceLimits
	}
	return nil
}

func (m *JobInfo) GetInput() *Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *JobInfo) GetNewBranch() *pfs.BranchInfo {
	if m != nil {
		return m.NewBranch
	}
	return nil
}

func (m *JobInfo) GetStatsCommit() *pfs.Commit {
	if m != nil {
		return m.StatsCommit
	}
	return nil
}

func (m *JobInfo) GetEnableStats() bool {
	if m != nil {
		return m.EnableStats
	}
	return false
}

func (m *JobInfo) GetSalt() string {
	if m != nil {
		return m.Salt
	}
	return ""
}

func (m *JobInfo) GetBatch() bool {
	if m != nil {
		return m.Batch
	}
	return false
}

func (m *JobInfo) GetChunkSpec() *ChunkSpec {
	if m != nil {
		return m.ChunkSpec
	}
	return nil
}

func (m *JobInfo) GetDatumTimeout() *types.Duration {
	if m != nil {
		return m.DatumTimeout
	}
	return nil
}

func (m *JobInfo) GetJobTimeout() *types.Duration {
	if m != nil {
		return m.JobTimeout
	}
	return nil
}

func (m *JobInfo) GetDatumTries() int64 {
	if m != nil {
		return m.DatumTries
	}
	return 0
}

func (m *JobInfo) GetSchedulingSpec() *SchedulingSpec {
	if m != nil {
		return m.SchedulingSpec
	}
	return nil
}

func (m *JobInfo) GetPodSpec() string {
	if m != nil {
		return m.PodSpec
	}
	return ""
}

func (m *JobInfo) GetPodPatch() string {
	if m != nil {
		return m.PodPatch
	}
	return ""
}

type Worker struct {
	Name                 string      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	State                WorkerState `protobuf:"varint,2,opt,name=state,proto3,enum=pps.WorkerState" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Worker) Reset()         { *m = Worker{} }
func (m *Worker) String() string { return proto.CompactTextString(m) }
func (*Worker) ProtoMessage()    {}
func (*Worker) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{25}
}
func (m *Worker) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Worker) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Worker.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Worker) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Worker.Merge(m, src)
}
func (m *Worker) XXX_Size() int {
	return m.Size()
}
func (m *Worker) XXX_DiscardUnknown() {
	xxx_messageInfo_Worker.DiscardUnknown(m)
}

var xxx_messageInfo_Worker proto.InternalMessageInfo

func (m *Worker) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Worker) GetState() WorkerState {
	if m != nil {
		return m.State
	}
	return WorkerState_POD_RUNNING
}

type JobInfos struct {
	JobInfo              []*JobInfo `protobuf:"bytes,1,rep,name=job_info,json=jobInfo,proto3" json:"job_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *JobInfos) Reset()         { *m = JobInfos{} }
func (m *JobInfos) String() string { return proto.CompactTextString(m) }
func (*JobInfos) ProtoMessage()    {}
func (*JobInfos) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{26}
}
func (m *JobInfos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobInfos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobInfos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobInfos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobInfos.Merge(m, src)
}
func (m *JobInfos) XXX_Size() int {
	return m.Size()
}
func (m *JobInfos) XXX_DiscardUnknown() {
	xxx_messageInfo_JobInfos.DiscardUnknown(m)
}

var xxx_messageInfo_JobInfos proto.InternalMessageInfo

func (m *JobInfos) GetJobInfo() []*JobInfo {
	if m != nil {
		return m.JobInfo
	}
	return nil
}

type Pipeline struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Pipeline) Reset()         { *m = Pipeline{} }
func (m *Pipeline) String() string { return proto.CompactTextString(m) }
func (*Pipeline) ProtoMessage()    {}
func (*Pipeline) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{27}
}
func (m *Pipeline) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pipeline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pipeline.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pipeline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pipeline.Merge(m, src)
}
func (m *Pipeline) XXX_Size() int {
	return m.Size()
}
func (m *Pipeline) XXX_DiscardUnknown() {
	xxx_messageInfo_Pipeline.DiscardUnknown(m)
}

var xxx_messageInfo_Pipeline proto.InternalMessageInfo

func (m *Pipeline) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type PipelineInput struct {
	Name                 string      `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	Repo                 *pfs.Repo   `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	Branch               string      `protobuf:"bytes,2,opt,name=branch,proto3" json:"branch,omitempty"`
	Glob                 string      `protobuf:"bytes,3,opt,name=glob,proto3" json:"glob,omitempty"`
	Lazy                 bool        `protobuf:"varint,4,opt,name=lazy,proto3" json:"lazy,omitempty"`
	From                 *pfs.Commit `protobuf:"bytes,6,opt,name=from,proto3" json:"from,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *PipelineInput) Reset()         { *m = PipelineInput{} }
func (m *PipelineInput) String() string { return proto.CompactTextString(m) }
func (*PipelineInput) ProtoMessage()    {}
func (*PipelineInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{28}
}
func (m *PipelineInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PipelineInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PipelineInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PipelineInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PipelineInput.Merge(m, src)
}
func (m *PipelineInput) XXX_Size() int {
	return m.Size()
}
func (m *PipelineInput) XXX_DiscardUnknown() {
	xxx_messageInfo_PipelineInput.DiscardUnknown(m)
}

var xxx_messageInfo_PipelineInput proto.InternalMessageInfo

func (m *PipelineInput) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PipelineInput) GetRepo() *pfs.Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *PipelineInput) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *PipelineInput) GetGlob() string {
	if m != nil {
		return m.Glob
	}
	return ""
}

func (m *PipelineInput) GetLazy() bool {
	if m != nil {
		return m.Lazy
	}
	return false
}

func (m *PipelineInput) GetFrom() *pfs.Commit {
	if m != nil {
		return m.From
	}
	return nil
}

// EtcdPipelineInfo is proto that Pachd stores in etcd for each pipeline. It
// tracks the state of the pipeline, and points to its metadata in PFS (and,
// by pointing to a PFS commit, de facto tracks the pipeline's version)
type EtcdPipelineInfo struct {
	State                PipelineState   `protobuf:"varint,1,opt,name=state,proto3,enum=pps.PipelineState" json:"state,omitempty"`
	Reason               string          `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	SpecCommit           *pfs.Commit     `protobuf:"bytes,2,opt,name=spec_commit,json=specCommit,proto3" json:"spec_commit,omitempty"`
	JobCounts            map[int32]int32 `protobuf:"bytes,3,rep,name=job_counts,json=jobCounts,proto3" json:"job_counts,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	AuthToken            string          `protobuf:"bytes,5,opt,name=auth_token,json=authToken,proto3" json:"auth_token,omitempty"`
	LastJobState         JobState        `protobuf:"varint,6,opt,name=last_job_state,json=lastJobState,proto3,enum=pps.JobState" json:"last_job_state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *EtcdPipelineInfo) Reset()         { *m = EtcdPipelineInfo{} }
func (m *EtcdPipelineInfo) String() string { return proto.CompactTextString(m) }
func (*EtcdPipelineInfo) ProtoMessage()    {}
func (*EtcdPipelineInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{29}
}
func (m *EtcdPipelineInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EtcdPipelineInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EtcdPipelineInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EtcdPipelineInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EtcdPipelineInfo.Merge(m, src)
}
func (m *EtcdPipelineInfo) XXX_Size() int {
	return m.Size()
}
func (m *EtcdPipelineInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_EtcdPipelineInfo.DiscardUnknown(m)
}

var xxx_messageInfo_EtcdPipelineInfo proto.InternalMessageInfo

func (m *EtcdPipelineInfo) GetState() PipelineState {
	if m != nil {
		return m.State
	}
	return PipelineState_PIPELINE_STARTING
}

func (m *EtcdPipelineInfo) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *EtcdPipelineInfo) GetSpecCommit() *pfs.Commit {
	if m != nil {
		return m.SpecCommit
	}
	return nil
}

func (m *EtcdPipelineInfo) GetJobCounts() map[int32]int32 {
	if m != nil {
		return m.JobCounts
	}
	return nil
}

func (m *EtcdPipelineInfo) GetAuthToken() string {
	if m != nil {
		return m.AuthToken
	}
	return ""
}

func (m *EtcdPipelineInfo) GetLastJobState() JobState {
	if m != nil {
		return m.LastJobState
	}
	return JobState_JOB_STARTING
}

type PipelineInfo struct {
	ID              string           `protobuf:"bytes,17,opt,name=id,proto3" json:"id,omitempty"`
	Pipeline        *Pipeline        `protobuf:"bytes,1,opt,name=pipeline,proto3" json:"pipeline,omitempty"`
	Version         uint64           `protobuf:"varint,11,opt,name=version,proto3" json:"version,omitempty"`
	Transform       *Transform       `protobuf:"bytes,2,opt,name=transform,proto3" json:"transform,omitempty"`
	ParallelismSpec *ParallelismSpec `protobuf:"bytes,10,opt,name=parallelism_spec,json=parallelismSpec,proto3" json:"parallelism_spec,omitempty"`
	HashtreeSpec    *HashtreeSpec    `protobuf:"bytes,42,opt,name=hashtree_spec,json=hashtreeSpec,proto3" json:"hashtree_spec,omitempty"`
	Egress          *Egress          `protobuf:"bytes,15,opt,name=egress,proto3" json:"egress,omitempty"`
	CreatedAt       *types.Timestamp `protobuf:"bytes,6,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// state indicates the current state of the pipeline. This is not stored in
	// PFS along with the rest of this data structure--PPS.InspectPipeline fills
	// it in
	State PipelineState `protobuf:"varint,7,opt,name=state,proto3,enum=pps.PipelineState" json:"state,omitempty"`
	// same for stopped field
	Stopped     bool   `protobuf:"varint,38,opt,name=stopped,proto3" json:"stopped,omitempty"`
	RecentError string `protobuf:"bytes,8,opt,name=recent_error,json=recentError,proto3" json:"recent_error,omitempty"`
	// job_counts and last_job_state indicates the number of jobs within this
	// pipeline in a given state and the state of the most recently created job,
	// respectively. This is not stored in PFS along with the rest of this data
	// structure--PPS.InspectPipeline fills it in from the EtcdPipelineInfo.
	JobCounts          map[int32]int32 `protobuf:"bytes,9,rep,name=job_counts,json=jobCounts,proto3" json:"job_counts,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	LastJobState       JobState        `protobuf:"varint,43,opt,name=last_job_state,json=lastJobState,proto3,enum=pps.JobState" json:"last_job_state,omitempty"`
	OutputBranch       string          `protobuf:"bytes,16,opt,name=output_branch,json=outputBranch,proto3" json:"output_branch,omitempty"`
	ScaleDownThreshold *types.Duration `protobuf:"bytes,18,opt,name=scale_down_threshold,json=scaleDownThreshold,proto3" json:"scale_down_threshold,omitempty"`
	ResourceRequests   *ResourceSpec   `protobuf:"bytes,19,opt,name=resource_requests,json=resourceRequests,proto3" json:"resource_requests,omitempty"`
	ResourceLimits     *ResourceSpec   `protobuf:"bytes,31,opt,name=resource_limits,json=resourceLimits,proto3" json:"resource_limits,omitempty"`
	Input              *Input          `protobuf:"bytes,20,opt,name=input,proto3" json:"input,omitempty"`
	Description        string          `protobuf:"bytes,21,opt,name=description,proto3" json:"description,omitempty"`
	CacheSize          string          `protobuf:"bytes,23,opt,name=cache_size,json=cacheSize,proto3" json:"cache_size,omitempty"`
	EnableStats        bool            `protobuf:"varint,24,opt,name=enable_stats,json=enableStats,proto3" json:"enable_stats,omitempty"`
	Salt               string          `protobuf:"bytes,25,opt,name=salt,proto3" json:"salt,omitempty"`
	Batch              bool            `protobuf:"varint,27,opt,name=batch,proto3" json:"batch,omitempty"`
	// reason includes any error messages associated with a failed pipeline
	Reason               string          `protobuf:"bytes,28,opt,name=reason,proto3" json:"reason,omitempty"`
	MaxQueueSize         int64           `protobuf:"varint,29,opt,name=max_queue_size,json=maxQueueSize,proto3" json:"max_queue_size,omitempty"`
	Service              *Service        `protobuf:"bytes,30,opt,name=service,proto3" json:"service,omitempty"`
	Spout                *Spout          `protobuf:"bytes,45,opt,name=spout,proto3" json:"spout,omitempty"`
	ChunkSpec            *ChunkSpec      `protobuf:"bytes,32,opt,name=chunk_spec,json=chunkSpec,proto3" json:"chunk_spec,omitempty"`
	DatumTimeout         *types.Duration `protobuf:"bytes,33,opt,name=datum_timeout,json=datumTimeout,proto3" json:"datum_timeout,omitempty"`
	JobTimeout           *types.Duration `protobuf:"bytes,34,opt,name=job_timeout,json=jobTimeout,proto3" json:"job_timeout,omitempty"`
	GithookURL           string          `protobuf:"bytes,35,opt,name=githook_url,json=githookUrl,proto3" json:"githook_url,omitempty"`
	SpecCommit           *pfs.Commit     `protobuf:"bytes,36,opt,name=spec_commit,json=specCommit,proto3" json:"spec_commit,omitempty"`
	Standby              bool            `protobuf:"varint,37,opt,name=standby,proto3" json:"standby,omitempty"`
	DatumTries           int64           `protobuf:"varint,39,opt,name=datum_tries,json=datumTries,proto3" json:"datum_tries,omitempty"`
	SchedulingSpec       *SchedulingSpec `protobuf:"bytes,40,opt,name=scheduling_spec,json=schedulingSpec,proto3" json:"scheduling_spec,omitempty"`
	PodSpec              string          `protobuf:"bytes,41,opt,name=pod_spec,json=podSpec,proto3" json:"pod_spec,omitempty"`
	PodPatch             string          `protobuf:"bytes,44,opt,name=pod_patch,json=podPatch,proto3" json:"pod_patch,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *PipelineInfo) Reset()         { *m = PipelineInfo{} }
func (m *PipelineInfo) String() string { return proto.CompactTextString(m) }
func (*PipelineInfo) ProtoMessage()    {}
func (*PipelineInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{30}
}
func (m *PipelineInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PipelineInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PipelineInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PipelineInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PipelineInfo.Merge(m, src)
}
func (m *PipelineInfo) XXX_Size() int {
	return m.Size()
}
func (m *PipelineInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PipelineInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PipelineInfo proto.InternalMessageInfo

func (m *PipelineInfo) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *PipelineInfo) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *PipelineInfo) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *PipelineInfo) GetTransform() *Transform {
	if m != nil {
		return m.Transform
	}
	return nil
}

func (m *PipelineInfo) GetParallelismSpec() *ParallelismSpec {
	if m != nil {
		return m.ParallelismSpec
	}
	return nil
}

func (m *PipelineInfo) GetHashtreeSpec() *HashtreeSpec {
	if m != nil {
		return m.HashtreeSpec
	}
	return nil
}

func (m *PipelineInfo) GetEgress() *Egress {
	if m != nil {
		return m.Egress
	}
	return nil
}

func (m *PipelineInfo) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *PipelineInfo) GetState() PipelineState {
	if m != nil {
		return m.State
	}
	return PipelineState_PIPELINE_STARTING
}

func (m *PipelineInfo) GetStopped() bool {
	if m != nil {
		return m.Stopped
	}
	return false
}

func (m *PipelineInfo) GetRecentError() string {
	if m != nil {
		return m.RecentError
	}
	return ""
}

func (m *PipelineInfo) GetJobCounts() map[int32]int32 {
	if m != nil {
		return m.JobCounts
	}
	return nil
}

func (m *PipelineInfo) GetLastJobState() JobState {
	if m != nil {
		return m.LastJobState
	}
	return JobState_JOB_STARTING
}

func (m *PipelineInfo) GetOutputBranch() string {
	if m != nil {
		return m.OutputBranch
	}
	return ""
}

func (m *PipelineInfo) GetScaleDownThreshold() *types.Duration {
	if m != nil {
		return m.ScaleDownThreshold
	}
	return nil
}

func (m *PipelineInfo) GetResourceRequests() *ResourceSpec {
	if m != nil {
		return m.ResourceRequests
	}
	return nil
}

func (m *PipelineInfo) GetResourceLimits() *ResourceSpec {
	if m != nil {
		return m.ResourceLimits
	}
	return nil
}

func (m *PipelineInfo) GetInput() *Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *PipelineInfo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *PipelineInfo) GetCacheSize() string {
	if m != nil {
		return m.CacheSize
	}
	return ""
}

func (m *PipelineInfo) GetEnableStats() bool {
	if m != nil {
		return m.EnableStats
	}
	return false
}

func (m *PipelineInfo) GetSalt() string {
	if m != nil {
		return m.Salt
	}
	return ""
}

func (m *PipelineInfo) GetBatch() bool {
	if m != nil {
		return m.Batch
	}
	return false
}

func (m *PipelineInfo) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *PipelineInfo) GetMaxQueueSize() int64 {
	if m != nil {
		return m.MaxQueueSize
	}
	return 0
}

func (m *PipelineInfo) GetService() *Service {
	if m != nil {
		return m.Service
	}
	return nil
}

func (m *PipelineInfo) GetSpout() *Spout {
	if m != nil {
		return m.Spout
	}
	return nil
}

func (m *PipelineInfo) GetChunkSpec() *ChunkSpec {
	if m != nil {
		return m.ChunkSpec
	}
	return nil
}

func (m *PipelineInfo) GetDatumTimeout() *types.Duration {
	if m != nil {
		return m.DatumTimeout
	}
	return nil
}

func (m *PipelineInfo) GetJobTimeout() *types.Duration {
	if m != nil {
		return m.JobTimeout
	}
	return nil
}

func (m *PipelineInfo) GetGithookURL() string {
	if m != nil {
		return m.GithookURL
	}
	return ""
}

func (m *PipelineInfo) GetSpecCommit() *pfs.Commit {
	if m != nil {
		return m.SpecCommit
	}
	return nil
}

func (m *PipelineInfo) GetStandby() bool {
	if m != nil {
		return m.Standby
	}
	return false
}

func (m *PipelineInfo) GetDatumTries() int64 {
	if m != nil {
		return m.DatumTries
	}
	return 0
}

func (m *PipelineInfo) GetSchedulingSpec() *SchedulingSpec {
	if m != nil {
		return m.SchedulingSpec
	}
	return nil
}

func (m *PipelineInfo) GetPodSpec() string {
	if m != nil {
		return m.PodSpec
	}
	return ""
}

func (m *PipelineInfo) GetPodPatch() string {
	if m != nil {
		return m.PodPatch
	}
	return ""
}

type PipelineInfos struct {
	PipelineInfo         []*PipelineInfo `protobuf:"bytes,1,rep,name=pipeline_info,json=pipelineInfo,proto3" json:"pipeline_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *PipelineInfos) Reset()         { *m = PipelineInfos{} }
func (m *PipelineInfos) String() string { return proto.CompactTextString(m) }
func (*PipelineInfos) ProtoMessage()    {}
func (*PipelineInfos) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{31}
}
func (m *PipelineInfos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PipelineInfos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PipelineInfos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PipelineInfos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PipelineInfos.Merge(m, src)
}
func (m *PipelineInfos) XXX_Size() int {
	return m.Size()
}
func (m *PipelineInfos) XXX_DiscardUnknown() {
	xxx_messageInfo_PipelineInfos.DiscardUnknown(m)
}

var xxx_messageInfo_PipelineInfos proto.InternalMessageInfo

func (m *PipelineInfos) GetPipelineInfo() []*PipelineInfo {
	if m != nil {
		return m.PipelineInfo
	}
	return nil
}

type CreateJobRequest struct {
	Pipeline             *Pipeline   `protobuf:"bytes,2,opt,name=pipeline,proto3" json:"pipeline,omitempty"`
	OutputCommit         *pfs.Commit `protobuf:"bytes,25,opt,name=output_commit,json=outputCommit,proto3" json:"output_commit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *CreateJobRequest) Reset()         { *m = CreateJobRequest{} }
func (m *CreateJobRequest) String() string { return proto.CompactTextString(m) }
func (*CreateJobRequest) ProtoMessage()    {}
func (*CreateJobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{32}
}
func (m *CreateJobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateJobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateJobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateJobRequest.Merge(m, src)
}
func (m *CreateJobRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateJobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateJobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateJobRequest proto.InternalMessageInfo

func (m *CreateJobRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *CreateJobRequest) GetOutputCommit() *pfs.Commit {
	if m != nil {
		return m.OutputCommit
	}
	return nil
}

type InspectJobRequest struct {
	// Callers should set either Job or OutputCommit, not both.
	Job                  *Job        `protobuf:"bytes,1,opt,name=job,proto3" json:"job,omitempty"`
	OutputCommit         *pfs.Commit `protobuf:"bytes,3,opt,name=output_commit,json=outputCommit,proto3" json:"output_commit,omitempty"`
	BlockState           bool        `protobuf:"varint,2,opt,name=block_state,json=blockState,proto3" json:"block_state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *InspectJobRequest) Reset()         { *m = InspectJobRequest{} }
func (m *InspectJobRequest) String() string { return proto.CompactTextString(m) }
func (*InspectJobRequest) ProtoMessage()    {}
func (*InspectJobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{33}
}
func (m *InspectJobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InspectJobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InspectJobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectJobRequest.Merge(m, src)
}
func (m *InspectJobRequest) XXX_Size() int {
	return m.Size()
}
func (m *InspectJobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectJobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InspectJobRequest proto.InternalMessageInfo

func (m *InspectJobRequest) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

func (m *InspectJobRequest) GetOutputCommit() *pfs.Commit {
	if m != nil {
		return m.OutputCommit
	}
	return nil
}

func (m *InspectJobRequest) GetBlockState() bool {
	if m != nil {
		return m.BlockState
	}
	return false
}

type ListJobRequest struct {
	Pipeline             *Pipeline     `protobuf:"bytes,1,opt,name=pipeline,proto3" json:"pipeline,omitempty"`
	InputCommit          []*pfs.Commit `protobuf:"bytes,2,rep,name=input_commit,json=inputCommit,proto3" json:"input_commit,omitempty"`
	OutputCommit         *pfs.Commit   `protobuf:"bytes,3,opt,name=output_commit,json=outputCommit,proto3" json:"output_commit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ListJobRequest) Reset()         { *m = ListJobRequest{} }
func (m *ListJobRequest) String() string { return proto.CompactTextString(m) }
func (*ListJobRequest) ProtoMessage()    {}
func (*ListJobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{34}
}
func (m *ListJobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListJobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListJobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListJobRequest.Merge(m, src)
}
func (m *ListJobRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListJobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListJobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListJobRequest proto.InternalMessageInfo

func (m *ListJobRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *ListJobRequest) GetInputCommit() []*pfs.Commit {
	if m != nil {
		return m.InputCommit
	}
	return nil
}

func (m *ListJobRequest) GetOutputCommit() *pfs.Commit {
	if m != nil {
		return m.OutputCommit
	}
	return nil
}

type FlushJobRequest struct {
	Commits              []*pfs.Commit `protobuf:"bytes,1,rep,name=commits,proto3" json:"commits,omitempty"`
	ToPipelines          []*Pipeline   `protobuf:"bytes,2,rep,name=to_pipelines,json=toPipelines,proto3" json:"to_pipelines,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *FlushJobRequest) Reset()         { *m = FlushJobRequest{} }
func (m *FlushJobRequest) String() string { return proto.CompactTextString(m) }
func (*FlushJobRequest) ProtoMessage()    {}
func (*FlushJobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{35}
}
func (m *FlushJobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlushJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlushJobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlushJobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlushJobRequest.Merge(m, src)
}
func (m *FlushJobRequest) XXX_Size() int {
	return m.Size()
}
func (m *FlushJobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FlushJobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FlushJobRequest proto.InternalMessageInfo

func (m *FlushJobRequest) GetCommits() []*pfs.Commit {
	if m != nil {
		return m.Commits
	}
	return nil
}

func (m *FlushJobRequest) GetToPipelines() []*Pipeline {
	if m != nil {
		return m.ToPipelines
	}
	return nil
}

type DeleteJobRequest struct {
	Job                  *Job     `protobuf:"bytes,1,opt,name=job,proto3" json:"job,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteJobRequest) Reset()         { *m = DeleteJobRequest{} }
func (m *DeleteJobRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteJobRequest) ProtoMessage()    {}
func (*DeleteJobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{36}
}
func (m *DeleteJobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteJobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteJobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteJobRequest.Merge(m, src)
}
func (m *DeleteJobRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteJobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteJobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteJobRequest proto.InternalMessageInfo

func (m *DeleteJobRequest) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

type StopJobRequest struct {
	Job                  *Job     `protobuf:"bytes,1,opt,name=job,proto3" json:"job,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StopJobRequest) Reset()         { *m = StopJobRequest{} }
func (m *StopJobRequest) String() string { return proto.CompactTextString(m) }
func (*StopJobRequest) ProtoMessage()    {}
func (*StopJobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{37}
}
func (m *StopJobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StopJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StopJobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StopJobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StopJobRequest.Merge(m, src)
}
func (m *StopJobRequest) XXX_Size() int {
	return m.Size()
}
func (m *StopJobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StopJobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StopJobRequest proto.InternalMessageInfo

func (m *StopJobRequest) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

type GetLogsRequest struct {
	// The pipeline from which we want to get logs (required if the job in 'job'
	// was created as part of a pipeline. To get logs from a non-orphan job
	// without the pipeline that created it, you need to use ElasticSearch).
	Pipeline *Pipeline `protobuf:"bytes,2,opt,name=pipeline,proto3" json:"pipeline,omitempty"`
	// The job from which we want to get logs.
	Job *Job `protobuf:"bytes,1,opt,name=job,proto3" json:"job,omitempty"`
	// Names of input files from which we want processing logs. This may contain
	// multiple files, to query pipelines that contain multiple inputs. Each
	// filter may be an absolute path of a file within a pps repo, or it may be
	// a hash for that file (to search for files at specific versions)
	DataFilters []string `protobuf:"bytes,3,rep,name=data_filters,json=dataFilters,proto3" json:"data_filters,omitempty"`
	Datum       *Datum   `protobuf:"bytes,6,opt,name=datum,proto3" json:"datum,omitempty"`
	// If true get logs from the master process
	Master bool `protobuf:"varint,5,opt,name=master,proto3" json:"master,omitempty"`
	// Continue to follow new logs as they become available.
	Follow bool `protobuf:"varint,7,opt,name=follow,proto3" json:"follow,omitempty"`
	// If nonzero, the number of lines from the end of the logs to return.  Note:
	// tail applies per container, so you will get tail * <number of pods> total
	// lines back.
	Tail                 int64    `protobuf:"varint,8,opt,name=tail,proto3" json:"tail,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetLogsRequest) Reset()         { *m = GetLogsRequest{} }
func (m *GetLogsRequest) String() string { return proto.CompactTextString(m) }
func (*GetLogsRequest) ProtoMessage()    {}
func (*GetLogsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{38}
}
func (m *GetLogsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLogsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLogsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLogsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLogsRequest.Merge(m, src)
}
func (m *GetLogsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetLogsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLogsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetLogsRequest proto.InternalMessageInfo

func (m *GetLogsRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *GetLogsRequest) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

func (m *GetLogsRequest) GetDataFilters() []string {
	if m != nil {
		return m.DataFilters
	}
	return nil
}

func (m *GetLogsRequest) GetDatum() *Datum {
	if m != nil {
		return m.Datum
	}
	return nil
}

func (m *GetLogsRequest) GetMaster() bool {
	if m != nil {
		return m.Master
	}
	return false
}

func (m *GetLogsRequest) GetFollow() bool {
	if m != nil {
		return m.Follow
	}
	return false
}

func (m *GetLogsRequest) GetTail() int64 {
	if m != nil {
		return m.Tail
	}
	return 0
}

// LogMessage is a log line from a PPS worker, annotated with metadata
// indicating when and why the line was logged.
type LogMessage struct {
	// The job and pipeline for which a PFS file is being processed (if the job
	// is an orphan job, pipeline name and ID will be unset)
	PipelineName string `protobuf:"bytes,1,opt,name=pipeline_name,json=pipelineName,proto3" json:"pipeline_name,omitempty"`
	JobID        string `protobuf:"bytes,3,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	WorkerID     string `protobuf:"bytes,7,opt,name=worker_id,json=workerId,proto3" json:"worker_id,omitempty"`
	DatumID      string `protobuf:"bytes,9,opt,name=datum_id,json=datumId,proto3" json:"datum_id,omitempty"`
	Master       bool   `protobuf:"varint,10,opt,name=master,proto3" json:"master,omitempty"`
	// The PFS files being processed (one per pipeline/job input)
	Data []*InputFile `protobuf:"bytes,4,rep,name=data,proto3" json:"data,omitempty"`
	// User is true if log message comes from the users code.
	User bool `protobuf:"varint,8,opt,name=user,proto3" json:"user,omitempty"`
	// The message logged, and the time at which it was logged
	Ts                   *types.Timestamp `protobuf:"bytes,5,opt,name=ts,proto3" json:"ts,omitempty"`
	Message              string           `protobuf:"bytes,6,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *LogMessage) Reset()         { *m = LogMessage{} }
func (m *LogMessage) String() string { return proto.CompactTextString(m) }
func (*LogMessage) ProtoMessage()    {}
func (*LogMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{39}
}
func (m *LogMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogMessage.Merge(m, src)
}
func (m *LogMessage) XXX_Size() int {
	return m.Size()
}
func (m *LogMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_LogMessage.DiscardUnknown(m)
}

var xxx_messageInfo_LogMessage proto.InternalMessageInfo

func (m *LogMessage) GetPipelineName() string {
	if m != nil {
		return m.PipelineName
	}
	return ""
}

func (m *LogMessage) GetJobID() string {
	if m != nil {
		return m.JobID
	}
	return ""
}

func (m *LogMessage) GetWorkerID() string {
	if m != nil {
		return m.WorkerID
	}
	return ""
}

func (m *LogMessage) GetDatumID() string {
	if m != nil {
		return m.DatumID
	}
	return ""
}

func (m *LogMessage) GetMaster() bool {
	if m != nil {
		return m.Master
	}
	return false
}

func (m *LogMessage) GetData() []*InputFile {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *LogMessage) GetUser() bool {
	if m != nil {
		return m.User
	}
	return false
}

func (m *LogMessage) GetTs() *types.Timestamp {
	if m != nil {
		return m.Ts
	}
	return nil
}

func (m *LogMessage) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type RestartDatumRequest struct {
	Job                  *Job     `protobuf:"bytes,1,opt,name=job,proto3" json:"job,omitempty"`
	DataFilters          []string `protobuf:"bytes,2,rep,name=data_filters,json=dataFilters,proto3" json:"data_filters,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RestartDatumRequest) Reset()         { *m = RestartDatumRequest{} }
func (m *RestartDatumRequest) String() string { return proto.CompactTextString(m) }
func (*RestartDatumRequest) ProtoMessage()    {}
func (*RestartDatumRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{40}
}
func (m *RestartDatumRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestartDatumRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RestartDatumRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RestartDatumRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestartDatumRequest.Merge(m, src)
}
func (m *RestartDatumRequest) XXX_Size() int {
	return m.Size()
}
func (m *RestartDatumRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RestartDatumRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RestartDatumRequest proto.InternalMessageInfo

func (m *RestartDatumRequest) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

func (m *RestartDatumRequest) GetDataFilters() []string {
	if m != nil {
		return m.DataFilters
	}
	return nil
}

type InspectDatumRequest struct {
	Datum                *Datum   `protobuf:"bytes,1,opt,name=datum,proto3" json:"datum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InspectDatumRequest) Reset()         { *m = InspectDatumRequest{} }
func (m *InspectDatumRequest) String() string { return proto.CompactTextString(m) }
func (*InspectDatumRequest) ProtoMessage()    {}
func (*InspectDatumRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{41}
}
func (m *InspectDatumRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectDatumRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InspectDatumRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InspectDatumRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectDatumRequest.Merge(m, src)
}
func (m *InspectDatumRequest) XXX_Size() int {
	return m.Size()
}
func (m *InspectDatumRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectDatumRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InspectDatumRequest proto.InternalMessageInfo

func (m *InspectDatumRequest) GetDatum() *Datum {
	if m != nil {
		return m.Datum
	}
	return nil
}

type ListDatumRequest struct {
	Job                  *Job     `protobuf:"bytes,1,opt,name=job,proto3" json:"job,omitempty"`
	PageSize             int64    `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	Page                 int64    `protobuf:"varint,3,opt,name=page,proto3" json:"page,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListDatumRequest) Reset()         { *m = ListDatumRequest{} }
func (m *ListDatumRequest) String() string { return proto.CompactTextString(m) }
func (*ListDatumRequest) ProtoMessage()    {}
func (*ListDatumRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{42}
}
func (m *ListDatumRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListDatumRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListDatumRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListDatumRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDatumRequest.Merge(m, src)
}
func (m *ListDatumRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListDatumRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDatumRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListDatumRequest proto.InternalMessageInfo

func (m *ListDatumRequest) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

func (m *ListDatumRequest) GetPageSize() int64 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListDatumRequest) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

type ListDatumResponse struct {
	DatumInfos           []*DatumInfo `protobuf:"bytes,1,rep,name=datum_infos,json=datumInfos,proto3" json:"datum_infos,omitempty"`
	TotalPages           int64        `protobuf:"varint,2,opt,name=total_pages,json=totalPages,proto3" json:"total_pages,omitempty"`
	Page                 int64        `protobuf:"varint,3,opt,name=page,proto3" json:"page,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ListDatumResponse) Reset()         { *m = ListDatumResponse{} }
func (m *ListDatumResponse) String() string { return proto.CompactTextString(m) }
func (*ListDatumResponse) ProtoMessage()    {}
func (*ListDatumResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{43}
}
func (m *ListDatumResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListDatumResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListDatumResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListDatumResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDatumResponse.Merge(m, src)
}
func (m *ListDatumResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListDatumResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDatumResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListDatumResponse proto.InternalMessageInfo

func (m *ListDatumResponse) GetDatumInfos() []*DatumInfo {
	if m != nil {
		return m.DatumInfos
	}
	return nil
}

func (m *ListDatumResponse) GetTotalPages() int64 {
	if m != nil {
		return m.TotalPages
	}
	return 0
}

func (m *ListDatumResponse) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

// ListDatumStreamResponse is identical to ListDatumResponse, except that only
// one DatumInfo is present (as these responses are streamed)
type ListDatumStreamResponse struct {
	DatumInfo *DatumInfo `protobuf:"bytes,1,opt,name=datum_info,json=datumInfo,proto3" json:"datum_info,omitempty"`
	// total_pages is only set in the first response (and set to 0 in all other
	// responses)
	TotalPages int64 `protobuf:"varint,2,opt,name=total_pages,json=totalPages,proto3" json:"total_pages,omitempty"`
	// page is only set in the first response (and set to 0 in all other
	// responses)
	Page                 int64    `protobuf:"varint,3,opt,name=page,proto3" json:"page,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListDatumStreamResponse) Reset()         { *m = ListDatumStreamResponse{} }
func (m *ListDatumStreamResponse) String() string { return proto.CompactTextString(m) }
func (*ListDatumStreamResponse) ProtoMessage()    {}
func (*ListDatumStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{44}
}
func (m *ListDatumStreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListDatumStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListDatumStreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListDatumStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDatumStreamResponse.Merge(m, src)
}
func (m *ListDatumStreamResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListDatumStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDatumStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListDatumStreamResponse proto.InternalMessageInfo

func (m *ListDatumStreamResponse) GetDatumInfo() *DatumInfo {
	if m != nil {
		return m.DatumInfo
	}
	return nil
}

func (m *ListDatumStreamResponse) GetTotalPages() int64 {
	if m != nil {
		return m.TotalPages
	}
	return 0
}

func (m *ListDatumStreamResponse) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

// ChunkSpec specifies how a pipeline should chunk its datums.
type ChunkSpec struct {
	// number, if nonzero, specifies that each chunk should contain `number`
	// datums. Chunks may contain fewer if the total number of datums don't
	// divide evenly.
	Number int64 `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
	// size_bytes, if nonzero, specifies a target size for each chunk of datums.
	// Chunks may be larger or smaller than size_bytes, but will usually be
	// pretty close to size_bytes in size.
	SizeBytes            int64    `protobuf:"varint,2,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChunkSpec) Reset()         { *m = ChunkSpec{} }
func (m *ChunkSpec) String() string { return proto.CompactTextString(m) }
func (*ChunkSpec) ProtoMessage()    {}
func (*ChunkSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{45}
}
func (m *ChunkSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChunkSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChunkSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChunkSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChunkSpec.Merge(m, src)
}
func (m *ChunkSpec) XXX_Size() int {
	return m.Size()
}
func (m *ChunkSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ChunkSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ChunkSpec proto.InternalMessageInfo

func (m *ChunkSpec) GetNumber() int64 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *ChunkSpec) GetSizeBytes() int64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

type SchedulingSpec struct {
	NodeSelector         map[string]string `protobuf:"bytes,1,rep,name=node_selector,json=nodeSelector,proto3" json:"node_selector,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	PriorityClassName    string            `protobuf:"bytes,2,opt,name=priority_class_name,json=priorityClassName,proto3" json:"priority_class_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *SchedulingSpec) Reset()         { *m = SchedulingSpec{} }
func (m *SchedulingSpec) String() string { return proto.CompactTextString(m) }
func (*SchedulingSpec) ProtoMessage()    {}
func (*SchedulingSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{46}
}
func (m *SchedulingSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchedulingSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchedulingSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchedulingSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchedulingSpec.Merge(m, src)
}
func (m *SchedulingSpec) XXX_Size() int {
	return m.Size()
}
func (m *SchedulingSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SchedulingSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SchedulingSpec proto.InternalMessageInfo

func (m *SchedulingSpec) GetNodeSelector() map[string]string {
	if m != nil {
		return m.NodeSelector
	}
	return nil
}

func (m *SchedulingSpec) GetPriorityClassName() string {
	if m != nil {
		return m.PriorityClassName
	}
	return ""
}

type CreatePipelineRequest struct {
	Pipeline           *Pipeline        `protobuf:"bytes,1,opt,name=pipeline,proto3" json:"pipeline,omitempty"`
	Transform          *Transform       `protobuf:"bytes,2,opt,name=transform,proto3" json:"transform,omitempty"`
	ParallelismSpec    *ParallelismSpec `protobuf:"bytes,7,opt,name=parallelism_spec,json=parallelismSpec,proto3" json:"parallelism_spec,omitempty"`
	HashtreeSpec       *HashtreeSpec    `protobuf:"bytes,31,opt,name=hashtree_spec,json=hashtreeSpec,proto3" json:"hashtree_spec,omitempty"`
	Egress             *Egress          `protobuf:"bytes,9,opt,name=egress,proto3" json:"egress,omitempty"`
	Update             bool             `protobuf:"varint,5,opt,name=update,proto3" json:"update,omitempty"`
	OutputBranch       string           `protobuf:"bytes,10,opt,name=output_branch,json=outputBranch,proto3" json:"output_branch,omitempty"`
	ScaleDownThreshold *types.Duration  `protobuf:"bytes,11,opt,name=scale_down_threshold,json=scaleDownThreshold,proto3" json:"scale_down_threshold,omitempty"`
	ResourceRequests   *ResourceSpec    `protobuf:"bytes,12,opt,name=resource_requests,json=resourceRequests,proto3" json:"resource_requests,omitempty"`
	ResourceLimits     *ResourceSpec    `protobuf:"bytes,22,opt,name=resource_limits,json=resourceLimits,proto3" json:"resource_limits,omitempty"`
	Input              *Input           `protobuf:"bytes,13,opt,name=input,proto3" json:"input,omitempty"`
	Description        string           `protobuf:"bytes,14,opt,name=description,proto3" json:"description,omitempty"`
	CacheSize          string           `protobuf:"bytes,16,opt,name=cache_size,json=cacheSize,proto3" json:"cache_size,omitempty"`
	EnableStats        bool             `protobuf:"varint,17,opt,name=enable_stats,json=enableStats,proto3" json:"enable_stats,omitempty"`
	// Reprocess forces the pipeline to reprocess all datums.
	// It only has meaning if Update is true
	Reprocess            bool            `protobuf:"varint,18,opt,name=reprocess,proto3" json:"reprocess,omitempty"`
	Batch                bool            `protobuf:"varint,19,opt,name=batch,proto3" json:"batch,omitempty"`
	MaxQueueSize         int64           `protobuf:"varint,20,opt,name=max_queue_size,json=maxQueueSize,proto3" json:"max_queue_size,omitempty"`
	Service              *Service        `protobuf:"bytes,21,opt,name=service,proto3" json:"service,omitempty"`
	Spout                *Spout          `protobuf:"bytes,33,opt,name=spout,proto3" json:"spout,omitempty"`
	ChunkSpec            *ChunkSpec      `protobuf:"bytes,23,opt,name=chunk_spec,json=chunkSpec,proto3" json:"chunk_spec,omitempty"`
	DatumTimeout         *types.Duration `protobuf:"bytes,24,opt,name=datum_timeout,json=datumTimeout,proto3" json:"datum_timeout,omitempty"`
	JobTimeout           *types.Duration `protobuf:"bytes,25,opt,name=job_timeout,json=jobTimeout,proto3" json:"job_timeout,omitempty"`
	Salt                 string          `protobuf:"bytes,26,opt,name=salt,proto3" json:"salt,omitempty"`
	Standby              bool            `protobuf:"varint,27,opt,name=standby,proto3" json:"standby,omitempty"`
	DatumTries           int64           `protobuf:"varint,28,opt,name=datum_tries,json=datumTries,proto3" json:"datum_tries,omitempty"`
	SchedulingSpec       *SchedulingSpec `protobuf:"bytes,29,opt,name=scheduling_spec,json=schedulingSpec,proto3" json:"scheduling_spec,omitempty"`
	PodSpec              string          `protobuf:"bytes,30,opt,name=pod_spec,json=podSpec,proto3" json:"pod_spec,omitempty"`
	PodPatch             string          `protobuf:"bytes,32,opt,name=pod_patch,json=podPatch,proto3" json:"pod_patch,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *CreatePipelineRequest) Reset()         { *m = CreatePipelineRequest{} }
func (m *CreatePipelineRequest) String() string { return proto.CompactTextString(m) }
func (*CreatePipelineRequest) ProtoMessage()    {}
func (*CreatePipelineRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{47}
}
func (m *CreatePipelineRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreatePipelineRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreatePipelineRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreatePipelineRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreatePipelineRequest.Merge(m, src)
}
func (m *CreatePipelineRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreatePipelineRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreatePipelineRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreatePipelineRequest proto.InternalMessageInfo

func (m *CreatePipelineRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *CreatePipelineRequest) GetTransform() *Transform {
	if m != nil {
		return m.Transform
	}
	return nil
}

func (m *CreatePipelineRequest) GetParallelismSpec() *ParallelismSpec {
	if m != nil {
		return m.ParallelismSpec
	}
	return nil
}

func (m *CreatePipelineRequest) GetHashtreeSpec() *HashtreeSpec {
	if m != nil {
		return m.HashtreeSpec
	}
	return nil
}

func (m *CreatePipelineRequest) GetEgress() *Egress {
	if m != nil {
		return m.Egress
	}
	return nil
}

func (m *CreatePipelineRequest) GetUpdate() bool {
	if m != nil {
		return m.Update
	}
	return false
}

func (m *CreatePipelineRequest) GetOutputBranch() string {
	if m != nil {
		return m.OutputBranch
	}
	return ""
}

func (m *CreatePipelineRequest) GetScaleDownThreshold() *types.Duration {
	if m != nil {
		return m.ScaleDownThreshold
	}
	return nil
}

func (m *CreatePipelineRequest) GetResourceRequests() *ResourceSpec {
	if m != nil {
		return m.ResourceRequests
	}
	return nil
}

func (m *CreatePipelineRequest) GetResourceLimits() *ResourceSpec {
	if m != nil {
		return m.ResourceLimits
	}
	return nil
}

func (m *CreatePipelineRequest) GetInput() *Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *CreatePipelineRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CreatePipelineRequest) GetCacheSize() string {
	if m != nil {
		return m.CacheSize
	}
	return ""
}

func (m *CreatePipelineRequest) GetEnableStats() bool {
	if m != nil {
		return m.EnableStats
	}
	return false
}

func (m *CreatePipelineRequest) GetReprocess() bool {
	if m != nil {
		return m.Reprocess
	}
	return false
}

func (m *CreatePipelineRequest) GetBatch() bool {
	if m != nil {
		return m.Batch
	}
	return false
}

func (m *CreatePipelineRequest) GetMaxQueueSize() int64 {
	if m != nil {
		return m.MaxQueueSize
	}
	return 0
}

func (m *CreatePipelineRequest) GetService() *Service {
	if m != nil {
		return m.Service
	}
	return nil
}

func (m *CreatePipelineRequest) GetSpout() *Spout {
	if m != nil {
		return m.Spout
	}
	return nil
}

func (m *CreatePipelineRequest) GetChunkSpec() *ChunkSpec {
	if m != nil {
		return m.ChunkSpec
	}
	return nil
}

func (m *CreatePipelineRequest) GetDatumTimeout() *types.Duration {
	if m != nil {
		return m.DatumTimeout
	}
	return nil
}

func (m *CreatePipelineRequest) GetJobTimeout() *types.Duration {
	if m != nil {
		return m.JobTimeout
	}
	return nil
}

func (m *CreatePipelineRequest) GetSalt() string {
	if m != nil {
		return m.Salt
	}
	return ""
}

func (m *CreatePipelineRequest) GetStandby() bool {
	if m != nil {
		return m.Standby
	}
	return false
}

func (m *CreatePipelineRequest) GetDatumTries() int64 {
	if m != nil {
		return m.DatumTries
	}
	return 0
}

func (m *CreatePipelineRequest) GetSchedulingSpec() *SchedulingSpec {
	if m != nil {
		return m.SchedulingSpec
	}
	return nil
}

func (m *CreatePipelineRequest) GetPodSpec() string {
	if m != nil {
		return m.PodSpec
	}
	return ""
}

func (m *CreatePipelineRequest) GetPodPatch() string {
	if m != nil {
		return m.PodPatch
	}
	return ""
}

type InspectPipelineRequest struct {
	Pipeline             *Pipeline `protobuf:"bytes,1,opt,name=pipeline,proto3" json:"pipeline,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *InspectPipelineRequest) Reset()         { *m = InspectPipelineRequest{} }
func (m *InspectPipelineRequest) String() string { return proto.CompactTextString(m) }
func (*InspectPipelineRequest) ProtoMessage()    {}
func (*InspectPipelineRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{48}
}
func (m *InspectPipelineRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectPipelineRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InspectPipelineRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InspectPipelineRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectPipelineRequest.Merge(m, src)
}
func (m *InspectPipelineRequest) XXX_Size() int {
	return m.Size()
}
func (m *InspectPipelineRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectPipelineRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InspectPipelineRequest proto.InternalMessageInfo

func (m *InspectPipelineRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

type ListPipelineRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListPipelineRequest) Reset()         { *m = ListPipelineRequest{} }
func (m *ListPipelineRequest) String() string { return proto.CompactTextString(m) }
func (*ListPipelineRequest) ProtoMessage()    {}
func (*ListPipelineRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{49}
}
func (m *ListPipelineRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListPipelineRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListPipelineRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListPipelineRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListPipelineRequest.Merge(m, src)
}
func (m *ListPipelineRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListPipelineRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListPipelineRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListPipelineRequest proto.InternalMessageInfo

type DeletePipelineRequest struct {
	Pipeline             *Pipeline `protobuf:"bytes,1,opt,name=pipeline,proto3" json:"pipeline,omitempty"`
	All                  bool      `protobuf:"varint,4,opt,name=all,proto3" json:"all,omitempty"`
	Force                bool      `protobuf:"varint,5,opt,name=force,proto3" json:"force,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *DeletePipelineRequest) Reset()         { *m = DeletePipelineRequest{} }
func (m *DeletePipelineRequest) String() string { return proto.CompactTextString(m) }
func (*DeletePipelineRequest) ProtoMessage()    {}
func (*DeletePipelineRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{50}
}
func (m *DeletePipelineRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeletePipelineRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeletePipelineRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeletePipelineRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeletePipelineRequest.Merge(m, src)
}
func (m *DeletePipelineRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeletePipelineRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeletePipelineRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeletePipelineRequest proto.InternalMessageInfo

func (m *DeletePipelineRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *DeletePipelineRequest) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

func (m *DeletePipelineRequest) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

type StartPipelineRequest struct {
	Pipeline             *Pipeline `protobuf:"bytes,1,opt,name=pipeline,proto3" json:"pipeline,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *StartPipelineRequest) Reset()         { *m = StartPipelineRequest{} }
func (m *StartPipelineRequest) String() string { return proto.CompactTextString(m) }
func (*StartPipelineRequest) ProtoMessage()    {}
func (*StartPipelineRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{51}
}
func (m *StartPipelineRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartPipelineRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartPipelineRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartPipelineRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartPipelineRequest.Merge(m, src)
}
func (m *StartPipelineRequest) XXX_Size() int {
	return m.Size()
}
func (m *StartPipelineRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StartPipelineRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StartPipelineRequest proto.InternalMessageInfo

func (m *StartPipelineRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

type StopPipelineRequest struct {
	Pipeline             *Pipeline `protobuf:"bytes,1,opt,name=pipeline,proto3" json:"pipeline,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *StopPipelineRequest) Reset()         { *m = StopPipelineRequest{} }
func (m *StopPipelineRequest) String() string { return proto.CompactTextString(m) }
func (*StopPipelineRequest) ProtoMessage()    {}
func (*StopPipelineRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{52}
}
func (m *StopPipelineRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StopPipelineRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StopPipelineRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StopPipelineRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StopPipelineRequest.Merge(m, src)
}
func (m *StopPipelineRequest) XXX_Size() int {
	return m.Size()
}
func (m *StopPipelineRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StopPipelineRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StopPipelineRequest proto.InternalMessageInfo

func (m *StopPipelineRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

type RunPipelineRequest struct {
	Pipeline             *Pipeline     `protobuf:"bytes,1,opt,name=pipeline,proto3" json:"pipeline,omitempty"`
	Provenance           []*pfs.Commit `protobuf:"bytes,2,rep,name=provenance,proto3" json:"provenance,omitempty"`
	BranchProvenance     []*pfs.Branch `protobuf:"bytes,3,rep,name=branch_provenance,json=branchProvenance,proto3" json:"branch_provenance,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *RunPipelineRequest) Reset()         { *m = RunPipelineRequest{} }
func (m *RunPipelineRequest) String() string { return proto.CompactTextString(m) }
func (*RunPipelineRequest) ProtoMessage()    {}
func (*RunPipelineRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{53}
}
func (m *RunPipelineRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunPipelineRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RunPipelineRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RunPipelineRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunPipelineRequest.Merge(m, src)
}
func (m *RunPipelineRequest) XXX_Size() int {
	return m.Size()
}
func (m *RunPipelineRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RunPipelineRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RunPipelineRequest proto.InternalMessageInfo

func (m *RunPipelineRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *RunPipelineRequest) GetProvenance() []*pfs.Commit {
	if m != nil {
		return m.Provenance
	}
	return nil
}

func (m *RunPipelineRequest) GetBranchProvenance() []*pfs.Branch {
	if m != nil {
		return m.BranchProvenance
	}
	return nil
}

type GarbageCollectRequest struct {
	// Memory is how much memory to use in computing which objects are alive. A
	// larger number will result in more precise garbage collection (at the
	// cost of more memory usage).
	MemoryBytes          int64    `protobuf:"varint,1,opt,name=memory_bytes,json=memoryBytes,proto3" json:"memory_bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GarbageCollectRequest) Reset()         { *m = GarbageCollectRequest{} }
func (m *GarbageCollectRequest) String() string { return proto.CompactTextString(m) }
func (*GarbageCollectRequest) ProtoMessage()    {}
func (*GarbageCollectRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{54}
}
func (m *GarbageCollectRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GarbageCollectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GarbageCollectRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GarbageCollectRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GarbageCollectRequest.Merge(m, src)
}
func (m *GarbageCollectRequest) XXX_Size() int {
	return m.Size()
}
func (m *GarbageCollectRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GarbageCollectRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GarbageCollectRequest proto.InternalMessageInfo

func (m *GarbageCollectRequest) GetMemoryBytes() int64 {
	if m != nil {
		return m.MemoryBytes
	}
	return 0
}

type GarbageCollectResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GarbageCollectResponse) Reset()         { *m = GarbageCollectResponse{} }
func (m *GarbageCollectResponse) String() string { return proto.CompactTextString(m) }
func (*GarbageCollectResponse) ProtoMessage()    {}
func (*GarbageCollectResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{55}
}
func (m *GarbageCollectResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GarbageCollectResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GarbageCollectResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GarbageCollectResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GarbageCollectResponse.Merge(m, src)
}
func (m *GarbageCollectResponse) XXX_Size() int {
	return m.Size()
}
func (m *GarbageCollectResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GarbageCollectResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GarbageCollectResponse proto.InternalMessageInfo

type ActivateAuthRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ActivateAuthRequest) Reset()         { *m = ActivateAuthRequest{} }
func (m *ActivateAuthRequest) String() string { return proto.CompactTextString(m) }
func (*ActivateAuthRequest) ProtoMessage()    {}
func (*ActivateAuthRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{56}
}
func (m *ActivateAuthRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActivateAuthRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActivateAuthRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActivateAuthRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActivateAuthRequest.Merge(m, src)
}
func (m *ActivateAuthRequest) XXX_Size() int {
	return m.Size()
}
func (m *ActivateAuthRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ActivateAuthRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ActivateAuthRequest proto.InternalMessageInfo

type ActivateAuthResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ActivateAuthResponse) Reset()         { *m = ActivateAuthResponse{} }
func (m *ActivateAuthResponse) String() string { return proto.CompactTextString(m) }
func (*ActivateAuthResponse) ProtoMessage()    {}
func (*ActivateAuthResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dbf57f97f56369c0, []int{57}
}
func (m *ActivateAuthResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActivateAuthResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActivateAuthResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActivateAuthResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActivateAuthResponse.Merge(m, src)
}
func (m *ActivateAuthResponse) XXX_Size() int {
	return m.Size()
}
func (m *ActivateAuthResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ActivateAuthResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ActivateAuthResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("pps.JobState", JobState_name, JobState_value)
	proto.RegisterEnum("pps.DatumState", DatumState_name, DatumState_value)
	proto.RegisterEnum("pps.WorkerState", WorkerState_name, WorkerState_value)
	proto.RegisterEnum("pps.PipelineState", PipelineState_name, PipelineState_value)
	proto.RegisterType((*Secret)(nil), "pps.Secret")
	proto.RegisterType((*Transform)(nil), "pps.Transform")
	proto.RegisterMapType((map[string]string)(nil), "pps.Transform.EnvEntry")
	proto.RegisterType((*Egress)(nil), "pps.Egress")
	proto.RegisterType((*Job)(nil), "pps.Job")
	proto.RegisterType((*Service)(nil), "pps.Service")
	proto.RegisterType((*Spout)(nil), "pps.Spout")
	proto.RegisterType((*AtomInput)(nil), "pps.AtomInput")
	proto.RegisterType((*PFSInput)(nil), "pps.PFSInput")
	proto.RegisterType((*CronInput)(nil), "pps.CronInput")
	proto.RegisterType((*GitInput)(nil), "pps.GitInput")
	proto.RegisterType((*Input)(nil), "pps.Input")
	proto.RegisterType((*JobInput)(nil), "pps.JobInput")
	proto.RegisterType((*ParallelismSpec)(nil), "pps.ParallelismSpec")
	proto.RegisterType((*HashtreeSpec)(nil), "pps.HashtreeSpec")
	proto.RegisterType((*InputFile)(nil), "pps.InputFile")
	proto.RegisterType((*Datum)(nil), "pps.Datum")
	proto.RegisterType((*DatumInfo)(nil), "pps.DatumInfo")
	proto.RegisterType((*Aggregate)(nil), "pps.Aggregate")
	proto.RegisterType((*ProcessStats)(nil), "pps.ProcessStats")
	proto.RegisterType((*AggregateProcessStats)(nil), "pps.AggregateProcessStats")
	proto.RegisterType((*WorkerStatus)(nil), "pps.WorkerStatus")
	proto.RegisterType((*ResourceSpec)(nil), "pps.ResourceSpec")
	proto.RegisterType((*GPUSpec)(nil), "pps.GPUSpec")
	proto.RegisterType((*EtcdJobInfo)(nil), "pps.EtcdJobInfo")
	proto.RegisterType((*JobInfo)(nil), "pps.JobInfo")
	proto.RegisterType((*Worker)(nil), "pps.Worker")
	proto.RegisterType((*JobInfos)(nil), "pps.JobInfos")
	proto.RegisterType((*Pipeline)(nil), "pps.Pipeline")
	proto.RegisterType((*PipelineInput)(nil), "pps.PipelineInput")
	proto.RegisterType((*EtcdPipelineInfo)(nil), "pps.EtcdPipelineInfo")
	proto.RegisterMapType((map[int32]int32)(nil), "pps.EtcdPipelineInfo.JobCountsEntry")
	proto.RegisterType((*PipelineInfo)(nil), "pps.PipelineInfo")
	proto.RegisterMapType((map[int32]int32)(nil), "pps.PipelineInfo.JobCountsEntry")
	proto.RegisterType((*PipelineInfos)(nil), "pps.PipelineInfos")
	proto.RegisterType((*CreateJobRequest)(nil), "pps.CreateJobRequest")
	proto.RegisterType((*InspectJobRequest)(nil), "pps.InspectJobRequest")
	proto.RegisterType((*ListJobRequest)(nil), "pps.ListJobRequest")
	proto.RegisterType((*FlushJobRequest)(nil), "pps.FlushJobRequest")
	proto.RegisterType((*DeleteJobRequest)(nil), "pps.DeleteJobRequest")
	proto.RegisterType((*StopJobRequest)(nil), "pps.StopJobRequest")
	proto.RegisterType((*GetLogsRequest)(nil), "pps.GetLogsRequest")
	proto.RegisterType((*LogMessage)(nil), "pps.LogMessage")
	proto.RegisterType((*RestartDatumRequest)(nil), "pps.RestartDatumRequest")
	proto.RegisterType((*InspectDatumRequest)(nil), "pps.InspectDatumRequest")
	proto.RegisterType((*ListDatumRequest)(nil), "pps.ListDatumRequest")
	proto.RegisterType((*ListDatumResponse)(nil), "pps.ListDatumResponse")
	proto.RegisterType((*ListDatumStreamResponse)(nil), "pps.ListDatumStreamResponse")
	proto.RegisterType((*ChunkSpec)(nil), "pps.ChunkSpec")
	proto.RegisterType((*SchedulingSpec)(nil), "pps.SchedulingSpec")
	proto.RegisterMapType((map[string]string)(nil), "pps.SchedulingSpec.NodeSelectorEntry")
	proto.RegisterType((*CreatePipelineRequest)(nil), "pps.CreatePipelineRequest")
	proto.RegisterType((*InspectPipelineRequest)(nil), "pps.InspectPipelineRequest")
	proto.RegisterType((*ListPipelineRequest)(nil), "pps.ListPipelineRequest")
	proto.RegisterType((*DeletePipelineRequest)(nil), "pps.DeletePipelineRequest")
	proto.RegisterType((*StartPipelineRequest)(nil), "pps.StartPipelineRequest")
	proto.RegisterType((*StopPipelineRequest)(nil), "pps.StopPipelineRequest")
	proto.RegisterType((*RunPipelineRequest)(nil), "pps.RunPipelineRequest")
	proto.RegisterType((*GarbageCollectRequest)(nil), "pps.GarbageCollectRequest")
	proto.RegisterType((*GarbageCollectResponse)(nil), "pps.GarbageCollectResponse")
	proto.RegisterType((*ActivateAuthRequest)(nil), "pps.ActivateAuthRequest")
	proto.RegisterType((*ActivateAuthResponse)(nil), "pps.ActivateAuthResponse")
}

func init() { proto.RegisterFile("client/pps/pps.proto", fileDescriptor_dbf57f97f56369c0) }

var fileDescriptor_dbf57f97f56369c0 = []byte{
	// 4436 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x5b, 0xcd, 0x6f, 0xdb, 0xd8,
	0x76, 0xb7, 0x24, 0x4a, 0x22, 0x8f, 0x3e, 0x4c, 0x5f, 0x7f, 0x44, 0x51, 0x12, 0xdb, 0xe1, 0x4c,
	0x32, 0x49, 0x26, 0xe3, 0xcc, 0x73, 0xde, 0x4b, 0xa7, 0xd3, 0xe9, 0xcc, 0xf3, 0x57, 0x52, 0x6b,
	0xfc, 0x32, 0x2e, 0x65, 0x4f, 0xd1, 0x6e, 0x04, 0x9a, 0xbc, 0x92, 0x18, 0x53, 0x24, 0x1f, 0x49,
	0x39, 0xe3, 0x01, 0xba, 0xe9, 0xa2, 0x7f, 0x40, 0x17, 0x45, 0x51, 0xa0, 0xab, 0x02, 0xdd, 0x74,
	0xd1, 0xa2, 0xeb, 0x2e, 0xba, 0x7c, 0x9b, 0x02, 0x6f, 0xf3, 0x16, 0xdd, 0x04, 0x45, 0x0a, 0x74,
	0xd7, 0x55, 0x97, 0x45, 0x81, 0xe2, 0x9e, 0x7b, 0x49, 0x91, 0x92, 0x2c, 0xdb, 0x71, 0x17, 0x6f,
	0x61, 0xe0, 0xde, 0x73, 0xce, 0xfd, 0x3a, 0xf7, 0xdc, 0x73, 0xce, 0xef, 0x50, 0x86, 0x25, 0xd3,
	0xb1, 0xa9, 0x1b, 0x3d, 0xf3, 0xfd, 0x90, 0xfd, 0x6d, 0xf8, 0x81, 0x17, 0x79, 0xa4, 0xe0, 0xfb,
	0x61, 0xf3, 0x4e, 0xcf, 0xf3, 0x7a, 0x0e, 0x7d, 0x86, 0xa4, 0x93, 0x61, 0xf7, 0x19, 0x1d, 0xf8,
	0xd1, 0x39, 0x97, 0x68, 0xae, 0x8d, 0x33, 0x23, 0x7b, 0x40, 0xc3, 0xc8, 0x18, 0xf8, 0x42, 0x60,
	0x75, 0x5c, 0xc0, 0x1a, 0x06, 0x46, 0x64, 0x7b, 0xae, 0xe0, 0x2f, 0xf5, 0xbc, 0x9e, 0x87, 0xcd,
	0x67, 0xac, 0x15, 0x53, 0xe3, 0xed, 0x74, 0x43, 0xf6, 0xc7, 0xa9, 0x5a, 0x17, 0x4a, 0x6d, 0x6a,
	0x06, 0x34, 0x22, 0x04, 0x24, 0xd7, 0x18, 0xd0, 0x46, 0x6e, 0x3d, 0xf7, 0x48, 0xd1, 0xb1, 0x4d,
	0x54, 0x28, 0x9c, 0xd2, 0xf3, 0x86, 0x84, 0x24, 0xd6, 0x24, 0xf7, 0x00, 0x06, 0xde, 0xd0, 0x8d,
	0x3a, 0xbe, 0x11, 0xf5, 0x1b, 0x79, 0x64, 0x28, 0x48, 0x39, 0x34, 0xa2, 0x3e, 0xb9, 0x05, 0x65,
	0xea, 0x9e, 0x75, 0xce, 0x8c, 0xa0, 0x51, 0x40, 0x5e, 0x89, 0xba, 0x67, 0xdf, 0x1b, 0x81, 0xf6,
	0xeb, 0x02, 0x28, 0x47, 0x81, 0xe1, 0x86, 0x5d, 0x2f, 0x18, 0x90, 0x25, 0x28, 0xda, 0x03, 0xa3,
	0x17, 0x2f, 0xc6, 0x3b, 0x6c, 0x35, 0x73, 0x60, 0x35, 0xf2, 0xeb, 0x05, 0xb6, 0x9a, 0x39, 0xb0,
	0x70, 0xba, 0x20, 0xe8, 0x30, 0x6a, 0x0d, 0xa9, 0x25, 0x1a, 0x04, 0x3b, 0x03, 0x8b, 0x3c, 0x86,
	0x02, 0x75, 0xcf, 0x1a, 0x85, 0xf5, 0xc2, 0xa3, 0xca, 0xe6, 0xad, 0x0d, 0xa6, 0xde, 0x64, 0xf6,
	0x8d, 0x3d, 0xf7, 0x6c, 0xcf, 0x8d, 0x82, 0x73, 0x9d, 0xc9, 0x90, 0x07, 0x50, 0x0e, 0xf1, 0x84,
	0x61, 0x43, 0x42, 0xf1, 0x0a, 0x8a, 0xf3, 0x53, 0xeb, 0x31, 0x8f, 0x3c, 0x05, 0x82, 0xbb, 0xe8,
	0xf8, 0x43, 0xc7, 0xe9, 0xc4, 0x23, 0x14, 0x5c, 0x55, 0x45, 0xce, 0xe1, 0xd0, 0x71, 0xda, 0x42,
	0x7a, 0x09, 0x8a, 0x61, 0x64, 0xd9, 0x6e, 0xa3, 0x88, 0x02, 0xbc, 0x43, 0xee, 0x80, 0xc2, 0xb6,
	0xcb, 0x39, 0x75, 0xe4, 0xc8, 0x34, 0x08, 0xda, 0xc8, 0x7c, 0x0a, 0xc4, 0x30, 0x4d, 0xea, 0x47,
	0x9d, 0x80, 0x46, 0xc3, 0xc0, 0xed, 0x98, 0x9e, 0x45, 0x1b, 0xa5, 0xf5, 0xc2, 0xa3, 0x82, 0xae,
	0x72, 0x8e, 0x8e, 0x8c, 0x1d, 0xcf, 0xa2, 0x6c, 0x01, 0x8b, 0x9e, 0x0c, 0x7b, 0x8d, 0xf2, 0x7a,
	0xee, 0x91, 0xac, 0xf3, 0x0e, 0xbb, 0xa3, 0x61, 0x48, 0x83, 0x06, 0xf0, 0x3b, 0x62, 0x6d, 0xb2,
	0x06, 0x95, 0xb7, 0x5e, 0x70, 0x6a, 0xbb, 0xbd, 0x8e, 0x65, 0x07, 0x8d, 0x0a, 0xb2, 0x40, 0x90,
	0x76, 0xed, 0x80, 0xac, 0x02, 0x58, 0x9e, 0x79, 0x4a, 0x83, 0xae, 0xed, 0xd0, 0x46, 0x95, 0xf3,
	0x47, 0x94, 0xe6, 0x0b, 0x90, 0x63, 0x8d, 0xc5, 0x17, 0x9e, 0x1b, 0x5d, 0xf8, 0x12, 0x14, 0xcf,
	0x0c, 0x67, 0x48, 0xc5, 0x5d, 0xf3, 0xce, 0x97, 0xf9, 0x2f, 0x72, 0x5a, 0x13, 0x4a, 0x7b, 0xbd,
	0x80, 0x86, 0x21, 0x1b, 0x75, 0xac, 0x1f, 0xc4, 0xa3, 0x8e, 0xf5, 0x03, 0xed, 0x1e, 0x14, 0x5a,
	0xde, 0x09, 0x59, 0x81, 0xbc, 0x6d, 0x71, 0xfa, 0x76, 0xe9, 0xfd, 0xbb, 0xb5, 0xfc, 0xfe, 0xae,
	0x9e, 0xb7, 0x2d, 0xed, 0x14, 0xca, 0x6d, 0x1a, 0x9c, 0xd9, 0x26, 0x25, 0x1f, 0x41, 0xcd, 0x76,
	0x23, 0x1a, 0xb8, 0x86, 0xd3, 0xf1, 0xbd, 0x20, 0x42, 0xe9, 0xa2, 0x5e, 0x8d, 0x89, 0x87, 0x5e,
	0x10, 0x31, 0x21, 0xfa, 0x43, 0x5a, 0x28, 0xcf, 0x85, 0x62, 0x22, 0x0a, 0xb1, 0xc5, 0x7c, 0x6e,
	0x76, 0x62, 0xb1, 0x43, 0x3d, 0x6f, 0xfb, 0xda, 0x03, 0x28, 0xb6, 0x7d, 0x6f, 0x18, 0x91, 0xbb,
	0xa0, 0x78, 0x67, 0x34, 0x78, 0x1b, 0xd8, 0x11, 0xb7, 0x3c, 0x59, 0x1f, 0x11, 0xb4, 0x7f, 0xca,
	0x81, 0xb2, 0x15, 0x79, 0x83, 0x7d, 0xd7, 0x1f, 0x4e, 0x7f, 0x0d, 0x04, 0xa4, 0x80, 0xfa, 0x9e,
	0xd0, 0x04, 0xb6, 0xc9, 0x0a, 0x94, 0x4e, 0x02, 0xc3, 0x35, 0xfb, 0xb1, 0xbd, 0xf3, 0x1e, 0xa3,
	0x9b, 0xde, 0x60, 0x60, 0x47, 0xe2, 0xf1, 0x88, 0x1e, 0x9b, 0xa3, 0xe7, 0x78, 0x27, 0x8d, 0x22,
	0x9f, 0x83, 0xb5, 0x19, 0xcd, 0x31, 0x7e, 0x3c, 0x6f, 0x94, 0x70, 0x4b, 0xd8, 0x66, 0xb7, 0x8a,
	0x3e, 0xa1, 0xc3, 0xae, 0x28, 0x6c, 0xc8, 0xc8, 0x02, 0x24, 0xbd, 0x64, 0x94, 0x96, 0x24, 0x97,
	0x55, 0x59, 0xfb, 0xfb, 0x1c, 0xc8, 0x87, 0x2f, 0xdb, 0xbf, 0x95, 0x7b, 0x2e, 0x8f, 0xef, 0x59,
	0xfb, 0x87, 0x1c, 0x28, 0x3b, 0x81, 0xe7, 0x5e, 0x7b, 0xbb, 0x62, 0x5b, 0x85, 0xf1, 0x6d, 0x85,
	0x3e, 0x35, 0xc5, 0x66, 0xb1, 0x9d, 0xbd, 0xe2, 0xd2, 0xd8, 0x15, 0x93, 0xcf, 0xd9, 0xab, 0x35,
	0x82, 0x08, 0x4f, 0x52, 0xd9, 0x6c, 0x6e, 0x70, 0x47, 0xba, 0x11, 0x3b, 0xd2, 0x8d, 0xa3, 0xd8,
	0xd3, 0xea, 0x5c, 0x50, 0xb3, 0x41, 0x7e, 0x65, 0x47, 0x17, 0xef, 0xf7, 0x36, 0x14, 0x86, 0x81,
	0xc3, 0xb7, 0xbb, 0x5d, 0x7e, 0xff, 0x6e, 0x8d, 0x59, 0xbf, 0xce, 0x68, 0xd7, 0xd5, 0xb2, 0xf6,
	0x9b, 0x1c, 0x14, 0xf9, 0x42, 0x1a, 0x48, 0x46, 0xe4, 0x0d, 0x70, 0xa1, 0xca, 0x66, 0x1d, 0xdd,
	0x55, 0x62, 0x99, 0x3a, 0xf2, 0xc8, 0x1a, 0x14, 0xfc, 0x6e, 0x88, 0x47, 0xac, 0x6c, 0xd6, 0x50,
	0x24, 0xb6, 0x03, 0x9d, 0x71, 0xc8, 0x3a, 0x14, 0xcd, 0xc0, 0x0b, 0x43, 0x74, 0xa7, 0x95, 0x4d,
	0x40, 0x11, 0xce, 0xe7, 0x0c, 0x26, 0x31, 0x74, 0x6d, 0xcf, 0x15, 0x5e, 0x34, 0x23, 0x81, 0x0c,
	0xb6, 0x11, 0x33, 0xf0, 0x5c, 0xdc, 0x68, 0xbc, 0x91, 0xe4, 0xfe, 0x74, 0xe4, 0xb1, 0x8d, 0xf4,
	0xec, 0x58, 0xa3, 0x7c, 0x23, 0xb1, 0xc6, 0x74, 0xc6, 0xd1, 0x4e, 0x41, 0x6e, 0x79, 0x27, 0x59,
	0x15, 0x4a, 0x29, 0x15, 0x7e, 0x94, 0xe8, 0x83, 0x9f, 0xb7, 0xb2, 0xc1, 0xa2, 0xd3, 0x0e, 0x92,
	0x26, 0x4c, 0x30, 0x3f, 0xc5, 0x04, 0x0b, 0x23, 0x13, 0xd4, 0x8e, 0x61, 0xfe, 0xd0, 0x08, 0x0c,
	0xc7, 0xa1, 0x8e, 0x1d, 0x0e, 0xda, 0xcc, 0x24, 0x9a, 0x20, 0x9b, 0x9e, 0x1b, 0x46, 0x86, 0xcb,
	0xdd, 0x86, 0xa4, 0x27, 0x7d, 0xb2, 0x0e, 0x15, 0xd3, 0xa3, 0xdd, 0xae, 0x6d, 0xb2, 0xd0, 0x88,
	0x33, 0xe5, 0xf4, 0x34, 0xa9, 0x25, 0xc9, 0x39, 0x35, 0xaf, 0x3d, 0x81, 0xea, 0x1f, 0x18, 0x61,
	0x3f, 0x0a, 0x28, 0x9d, 0x98, 0x33, 0x97, 0x9d, 0x53, 0x7b, 0x0e, 0x0a, 0x1e, 0x96, 0x99, 0x3c,
	0xdb, 0x23, 0x06, 0x4a, 0x71, 0x60, 0xd6, 0x66, 0xb4, 0xbe, 0x11, 0xf6, 0x51, 0x65, 0x55, 0x1d,
	0xdb, 0xda, 0xef, 0x41, 0x71, 0xd7, 0x88, 0x86, 0x83, 0x8b, 0x3c, 0x26, 0x69, 0x42, 0xe1, 0x8d,
	0x38, 0x7f, 0x65, 0x53, 0x46, 0x35, 0xb7, 0xbc, 0x13, 0x9d, 0x11, 0xb5, 0x5f, 0xe5, 0x40, 0xc1,
	0xd1, 0xfb, 0x6e, 0xd7, 0x63, 0xd7, 0x6a, 0xb1, 0x8e, 0x50, 0x27, 0xbf, 0x56, 0x64, 0xeb, 0x9c,
	0x41, 0x1e, 0xe0, 0x33, 0x88, 0xb8, 0x4b, 0xaf, 0x6f, 0xce, 0x8f, 0x24, 0xda, 0x8c, 0xac, 0x73,
	0x2e, 0xf9, 0x84, 0x8b, 0x85, 0xa8, 0x96, 0xca, 0xe6, 0x02, 0x37, 0xb2, 0xc0, 0x33, 0x69, 0x18,
	0x32, 0xc1, 0x90, 0x0b, 0x86, 0xe4, 0x21, 0x28, 0x7e, 0x37, 0xec, 0xf0, 0x39, 0xb9, 0xad, 0x28,
	0x78, 0x89, 0x4c, 0x05, 0xba, 0xec, 0x77, 0x51, 0x9c, 0x92, 0xfb, 0x20, 0x59, 0x46, 0x64, 0x60,
	0xcc, 0x44, 0x5b, 0x11, 0x22, 0x6c, 0xdb, 0x3a, 0xb2, 0xb4, 0x7f, 0x64, 0x4e, 0xb8, 0xd7, 0x0b,
	0x68, 0x8f, 0x0d, 0x58, 0x82, 0xa2, 0xc9, 0x52, 0x0b, 0x3c, 0x4a, 0x41, 0xe7, 0x1d, 0xa6, 0xbf,
	0x01, 0x35, 0x5c, 0xdc, 0x7d, 0x4e, 0xc7, 0x36, 0x7b, 0x54, 0x61, 0x64, 0x59, 0xf4, 0x4c, 0xdc,
	0xa1, 0xe8, 0x91, 0xc7, 0xa0, 0x76, 0xed, 0x6e, 0xd4, 0xef, 0xf8, 0x34, 0x30, 0xa9, 0x1b, 0xb1,
	0x08, 0x28, 0xa1, 0xc4, 0x3c, 0xd2, 0x0f, 0x13, 0x32, 0x79, 0x01, 0xb7, 0x5c, 0xdb, 0xa5, 0xe8,
	0xbe, 0xc6, 0x46, 0x14, 0x71, 0xc4, 0x32, 0x67, 0xbf, 0xcc, 0x8e, 0xd3, 0xfe, 0x22, 0x0f, 0xd5,
	0xb4, 0x56, 0xc8, 0xd7, 0x50, 0xb3, 0xbc, 0xb7, 0xae, 0xe3, 0x19, 0x56, 0x87, 0xa5, 0x6e, 0xe2,
	0x22, 0x6e, 0x4f, 0x78, 0x9b, 0x5d, 0x91, 0xb6, 0xe9, 0xd5, 0x58, 0x9e, 0xf9, 0x1f, 0xf2, 0x15,
	0x54, 0x7d, 0x3e, 0x1f, 0x1f, 0x9e, 0xbf, 0x6c, 0x78, 0x45, 0x88, 0xe3, 0xe8, 0x2f, 0xa1, 0x32,
	0xf4, 0x47, 0x6b, 0x17, 0x2e, 0x1b, 0x0c, 0x5c, 0x1a, 0xc7, 0x3e, 0x80, 0x7a, 0xb2, 0xf3, 0x93,
	0xf3, 0x88, 0x86, 0xa8, 0x2b, 0x49, 0x4f, 0xce, 0xb3, 0xcd, 0x88, 0xe4, 0x3e, 0x54, 0xc5, 0x12,
	0x5c, 0xa8, 0x88, 0x42, 0x62, 0x59, 0x14, 0xd1, 0xfe, 0x3a, 0x0f, 0xcb, 0xc9, 0x3d, 0x66, 0xb4,
	0xf3, 0x7c, 0xba, 0x76, 0x84, 0x97, 0x8b, 0x87, 0x8c, 0xa9, 0xe4, 0x27, 0x53, 0x55, 0x32, 0x3e,
	0x26, 0xa3, 0x87, 0x67, 0xd3, 0xf4, 0x30, 0x3e, 0x22, 0x7d, 0xf8, 0x9f, 0x4d, 0x3d, 0xfc, 0xe4,
	0x98, 0x31, 0x65, 0xfc, 0x64, 0x8a, 0x32, 0xa6, 0x6c, 0x2d, 0xad, 0x9c, 0xff, 0xcd, 0x41, 0xf5,
	0x8f, 0xbc, 0xe0, 0x94, 0x06, 0x4c, 0x25, 0xc3, 0x90, 0x3c, 0x06, 0xe5, 0x2d, 0xf6, 0x3b, 0xc9,
	0xdb, 0xaf, 0xbe, 0x7f, 0xb7, 0x26, 0x73, 0xa1, 0xfd, 0x5d, 0x5d, 0xe6, 0xec, 0x7d, 0x8b, 0xac,
	0x43, 0xe9, 0x8d, 0x77, 0xc2, 0xe4, 0x78, 0xcc, 0x51, 0xde, 0xbf, 0x5b, 0x2b, 0x32, 0xff, 0xba,
	0xab, 0x17, 0xdf, 0x78, 0x27, 0xfb, 0x16, 0x73, 0xda, 0xf8, 0xca, 0xb8, 0x57, 0xaf, 0x8f, 0xbc,
	0x3a, 0xbe, 0x46, 0xe4, 0x91, 0x9f, 0x42, 0x19, 0xe3, 0x1b, 0xb5, 0xc4, 0x21, 0x67, 0x85, 0xc2,
	0x58, 0x74, 0xe4, 0x10, 0x8a, 0x97, 0x38, 0x84, 0x7b, 0x00, 0xbf, 0x1c, 0xd2, 0x21, 0xed, 0x84,
	0xf6, 0x8f, 0x3c, 0x0c, 0x17, 0x74, 0x05, 0x29, 0x6d, 0xfb, 0x47, 0xaa, 0x05, 0x50, 0xd5, 0x69,
	0xe8, 0x0d, 0x03, 0x93, 0x7b, 0x53, 0x96, 0xf7, 0xfb, 0x43, 0x3c, 0x78, 0x5e, 0x67, 0x4d, 0xf6,
	0x9c, 0x07, 0x74, 0xe0, 0x05, 0xe7, 0xc2, 0xe1, 0x8b, 0x1e, 0x59, 0x85, 0x42, 0xcf, 0x1f, 0x8a,
	0xf5, 0xab, 0x3c, 0xd8, 0x1c, 0x1e, 0xb3, 0x49, 0x74, 0xc6, 0x60, 0xae, 0xc1, 0xb2, 0xc3, 0xd3,
	0xd8, 0xdd, 0xb2, 0x76, 0x4b, 0x92, 0x0b, 0xaa, 0xa4, 0xfd, 0x0c, 0xca, 0x42, 0x92, 0x09, 0x45,
	0xe7, 0x7e, 0x12, 0xc7, 0x59, 0x9b, 0x2d, 0xe8, 0x0e, 0x07, 0x27, 0x34, 0xc0, 0x05, 0x0b, 0xba,
	0xe8, 0x69, 0xbf, 0x91, 0xa0, 0xb2, 0x17, 0x99, 0x16, 0x46, 0xb0, 0xae, 0x17, 0xbb, 0xe1, 0xdc,
	0x14, 0x37, 0x4c, 0x1e, 0x83, 0xec, 0xdb, 0x3e, 0x75, 0x6c, 0x37, 0x36, 0x50, 0x11, 0x97, 0x05,
	0x51, 0x4f, 0xd8, 0xe4, 0x73, 0xa8, 0x79, 0xc3, 0xc8, 0x1f, 0x46, 0x9d, 0x54, 0x66, 0x33, 0x16,
	0xfa, 0xaa, 0x5c, 0x82, 0xf7, 0x48, 0x03, 0xca, 0x01, 0xe5, 0xc9, 0x0b, 0x7f, 0x93, 0x71, 0x17,
	0x1f, 0xad, 0x11, 0x19, 0x1d, 0x61, 0xfc, 0xd4, 0x42, 0xf5, 0x14, 0xf4, 0x1a, 0xa3, 0x1e, 0xc6,
	0x44, 0xf6, 0x68, 0x51, 0x2c, 0x3c, 0xb5, 0x7d, 0x9f, 0x5a, 0xe2, 0x56, 0x2a, 0x8c, 0xd6, 0xe6,
	0x24, 0x76, 0x6d, 0x28, 0x12, 0x79, 0x91, 0xe1, 0x60, 0xfa, 0x56, 0xd0, 0x15, 0x46, 0x39, 0x62,
	0x04, 0x96, 0xde, 0x21, 0xbb, 0x6b, 0xd8, 0x0e, 0xb5, 0x30, 0x25, 0x2d, 0xe8, 0x38, 0xe2, 0x25,
	0x52, 0x92, 0x9d, 0x04, 0xd4, 0x64, 0x39, 0x17, 0xb5, 0x1a, 0xf3, 0xa3, 0x9d, 0xe8, 0x31, 0x71,
	0x64, 0x46, 0xca, 0x25, 0x66, 0xb4, 0x01, 0x55, 0x6c, 0xc4, 0x4a, 0x82, 0x49, 0x25, 0x55, 0x50,
	0x40, 0xe8, 0xe8, 0xa3, 0x38, 0xae, 0x55, 0x30, 0xae, 0xd5, 0xe2, 0xeb, 0xc9, 0x44, 0xb5, 0x15,
	0x28, 0x05, 0xd4, 0x08, 0x3d, 0x57, 0x20, 0x21, 0xd1, 0x4b, 0x3f, 0x89, 0xda, 0xd5, 0x9f, 0xc4,
	0x0b, 0x90, 0xbb, 0xb6, 0x6b, 0x87, 0x7d, 0x6a, 0x35, 0xea, 0x97, 0x0e, 0x4b, 0x64, 0xb5, 0xff,
	0xa9, 0x42, 0xf9, 0x2a, 0x36, 0xf5, 0x14, 0x94, 0x28, 0xc6, 0xb5, 0x19, 0xaf, 0x97, 0xa0, 0x5d,
	0x7d, 0x24, 0x90, 0xb1, 0xc0, 0xc2, 0x6c, 0x0b, 0x7c, 0x0c, 0x6a, 0xdc, 0xee, 0x9c, 0xd1, 0x20,
	0x64, 0x79, 0x60, 0x0d, 0x0d, 0x6b, 0x3e, 0xa6, 0x7f, 0xcf, 0xc9, 0xe4, 0x1b, 0x50, 0xfd, 0x51,
	0x4e, 0xd5, 0xc1, 0x9c, 0xbb, 0x8a, 0xb3, 0x2f, 0xf1, 0xd9, 0xb3, 0x09, 0x97, 0x3e, 0xef, 0x8f,
	0x65, 0x60, 0x1f, 0x41, 0x89, 0x22, 0x50, 0x44, 0x7b, 0x88, 0x01, 0x38, 0xc7, 0x8e, 0xba, 0x60,
	0x91, 0x4f, 0x00, 0x7c, 0x23, 0xa0, 0x6e, 0xd4, 0x61, 0xca, 0x28, 0x8d, 0x29, 0x43, 0xe1, 0x3c,
	0x86, 0x29, 0x53, 0x17, 0x55, 0xfe, 0xb0, 0x8b, 0x92, 0xaf, 0x7e, 0x51, 0x93, 0x2f, 0x55, 0xb9,
	0xec, 0xa5, 0x26, 0x56, 0x08, 0x57, 0xb2, 0xc2, 0x8f, 0x32, 0x56, 0xf8, 0x10, 0xca, 0x21, 0x07,
	0xc6, 0xc2, 0x9c, 0xaa, 0xa2, 0x58, 0x81, 0x34, 0x3d, 0x66, 0xb2, 0x24, 0x2f, 0x64, 0x98, 0xb6,
	0xf1, 0x59, 0x2a, 0xc9, 0x43, 0x94, 0xab, 0x73, 0x06, 0x79, 0x02, 0x15, 0xb1, 0x71, 0x04, 0x54,
	0x24, 0x95, 0x96, 0xe9, 0xd4, 0xf7, 0x74, 0xe0, 0x5c, 0xd6, 0x66, 0xf0, 0x5a, 0xc8, 0x0a, 0xc4,
	0xb2, 0x80, 0x9b, 0x12, 0xe7, 0xda, 0xe6, 0xb8, 0x25, 0xe5, 0x81, 0x96, 0x2e, 0xf3, 0x40, 0x2b,
	0x57, 0xf1, 0x40, 0xab, 0x93, 0x1e, 0x68, 0xcc, 0xc5, 0x3c, 0xba, 0x82, 0x8b, 0xd9, 0x98, 0xe6,
	0x62, 0xb2, 0x9e, 0xec, 0xd6, 0xb8, 0x27, 0x4b, 0x3c, 0xd0, 0xda, 0x25, 0x1e, 0xe8, 0x05, 0xd4,
	0x44, 0x60, 0x0e, 0x31, 0x52, 0x37, 0x1a, 0x18, 0x54, 0xf9, 0x80, 0x74, 0x08, 0xd7, 0xab, 0x6f,
	0xd3, 0x01, 0xfd, 0x6b, 0x58, 0x08, 0x44, 0x84, 0xeb, 0x04, 0xf4, 0x97, 0x43, 0x1a, 0x46, 0x61,
	0xe3, 0x76, 0x6a, 0xb1, 0x74, 0xfc, 0xd3, 0xd5, 0x58, 0x56, 0x17, 0xa2, 0xe4, 0x4b, 0x98, 0x4f,
	0xc6, 0x3b, 0xf6, 0xc0, 0x8e, 0xc2, 0xc6, 0xc7, 0x17, 0x8d, 0xae, 0xc7, 0x92, 0x07, 0x28, 0xc8,
	0x4c, 0xc3, 0x66, 0xe1, 0xbe, 0xd1, 0x4c, 0x99, 0x86, 0x80, 0x75, 0xc8, 0x20, 0x1b, 0x00, 0x2e,
	0x7d, 0x1b, 0xdf, 0xf5, 0x1d, 0x14, 0x9b, 0x47, 0xcb, 0xe0, 0x57, 0x8d, 0xf9, 0xb8, 0xe2, 0xd2,
	0xb7, 0xe2, 0xe6, 0xc7, 0xfd, 0xf0, 0xbd, 0x4b, 0xfc, 0xf0, 0x7d, 0xa8, 0x52, 0xd7, 0x38, 0x71,
	0x68, 0x87, 0x6b, 0x79, 0x1d, 0x01, 0x5a, 0x85, 0xd3, 0x78, 0x16, 0xc8, 0xb0, 0xbb, 0xe1, 0x44,
	0x8d, 0xfb, 0x02, 0xbb, 0x1b, 0x4e, 0xc4, 0xb2, 0xfd, 0x13, 0x23, 0x32, 0xfb, 0x0d, 0x8d, 0x97,
	0xbc, 0xb0, 0x43, 0x3e, 0x03, 0x30, 0xfb, 0x43, 0xf7, 0x94, 0xfb, 0x9d, 0x07, 0x69, 0x24, 0xca,
	0xc8, 0xa8, 0x02, 0xc5, 0x8c, 0x9b, 0x98, 0x7c, 0x33, 0x24, 0x83, 0x59, 0x1f, 0x7b, 0x20, 0x0f,
	0x2f, 0x4f, 0xbe, 0x99, 0xfc, 0x11, 0x17, 0x67, 0xe9, 0x33, 0xcb, 0xaf, 0xe2, 0xd1, 0x9f, 0x5c,
	0x9a, 0x3e, 0xbf, 0xf1, 0x4e, 0xe2, 0xb1, 0xdc, 0x7a, 0xd9, 0xda, 0x81, 0x4d, 0xc3, 0xc6, 0xe3,
	0xc4, 0x7a, 0x87, 0x83, 0x23, 0x46, 0x21, 0x5f, 0xc1, 0x7c, 0x68, 0xf6, 0xa9, 0x35, 0x74, 0x6c,
	0xb7, 0xc7, 0x0f, 0xf4, 0x04, 0x17, 0x58, 0xe4, 0xef, 0x37, 0xe1, 0xf1, 0x8b, 0x0d, 0x33, 0x7d,
	0x72, 0x1b, 0x64, 0xdf, 0xb3, 0xf8, 0xb0, 0x4f, 0x51, 0x6f, 0x65, 0xdf, 0xb3, 0x90, 0x75, 0x07,
	0x14, 0xc6, 0xf2, 0x51, 0x7d, 0x4f, 0x91, 0xc7, 0x64, 0x0f, 0x59, 0xbf, 0x25, 0xc9, 0x92, 0x5a,
	0x6c, 0x49, 0x72, 0x51, 0x2d, 0xb5, 0x24, 0xf9, 0xae, 0x7a, 0x4f, 0xdb, 0x85, 0x12, 0x37, 0xde,
	0xa9, 0x35, 0x8d, 0x87, 0x59, 0x78, 0xa8, 0x8e, 0x19, 0x7b, 0xec, 0xc3, 0xb4, 0xe7, 0x02, 0xd8,
	0x77, 0x3d, 0xe6, 0xbd, 0x65, 0x4c, 0x4b, 0xdd, 0xae, 0xd7, 0xc8, 0xe1, 0x1b, 0xa9, 0xc6, 0x7e,
	0x0f, 0xad, 0xa9, 0xfc, 0x86, 0x37, 0xb4, 0x55, 0x90, 0xe3, 0x68, 0x34, 0x6d, 0x71, 0xed, 0x6f,
	0x73, 0x50, 0x8b, 0x05, 0xb2, 0x35, 0x83, 0x62, 0x6a, 0x8b, 0xf7, 0x44, 0x99, 0x28, 0x37, 0xee,
	0xd5, 0xc6, 0x0b, 0x5c, 0xf9, 0x4c, 0xe9, 0x25, 0xae, 0x22, 0x14, 0xa6, 0x54, 0x11, 0xa4, 0x4c,
	0x21, 0x4b, 0xea, 0x06, 0xde, 0x40, 0x44, 0xa1, 0x8c, 0xa1, 0x23, 0x43, 0xfb, 0xb7, 0x3c, 0xa8,
	0x2c, 0x2d, 0x1c, 0xed, 0xb4, 0xeb, 0x91, 0x47, 0xb1, 0xde, 0x72, 0xa8, 0x37, 0x92, 0x09, 0xbd,
	0x17, 0x78, 0x7f, 0x29, 0xe3, 0xfd, 0x9f, 0x42, 0x85, 0xdd, 0x6e, 0xfc, 0xce, 0xf2, 0x93, 0xcb,
	0x03, 0xe3, 0x8b, 0x67, 0xb6, 0x03, 0xcc, 0xf8, 0x3a, 0x08, 0x8a, 0x43, 0x91, 0xee, 0x7f, 0xcc,
	0x43, 0xeb, 0xd8, 0xd6, 0xd8, 0x35, 0xec, 0xa0, 0x18, 0xaf, 0x8b, 0x2b, 0x6f, 0xe2, 0x3e, 0xf3,
	0x94, 0xc6, 0x30, 0xea, 0x77, 0x22, 0xef, 0x94, 0xba, 0x42, 0xc7, 0x0a, 0xa3, 0x1c, 0x31, 0x02,
	0x79, 0x0e, 0x75, 0xc7, 0x08, 0x31, 0x26, 0x0b, 0x7c, 0x5f, 0x9a, 0x16, 0xd5, 0xaa, 0x4c, 0x28,
	0xee, 0x35, 0xbf, 0x82, 0x7a, 0x76, 0xc1, 0x74, 0x59, 0xb9, 0x38, 0xa5, 0xac, 0x5c, 0x4c, 0x97,
	0x95, 0xff, 0xbc, 0x06, 0xd5, 0x8c, 0x5e, 0x79, 0x49, 0x64, 0x61, 0xa2, 0x24, 0x92, 0xce, 0x76,
	0x72, 0xb3, 0xb3, 0x9d, 0x06, 0x94, 0xe3, 0x24, 0xa7, 0xc2, 0x63, 0x97, 0xe8, 0x5e, 0x33, 0xc1,
	0x9a, 0x96, 0x0a, 0xc1, 0x75, 0x52, 0xa1, 0x17, 0x50, 0xeb, 0x8b, 0x42, 0x52, 0xfa, 0xfd, 0x73,
	0xb7, 0x9e, 0x2e, 0x31, 0xe9, 0xd5, 0x7e, 0xba, 0xe0, 0x74, 0xa5, 0x14, 0xea, 0x77, 0x01, 0xcc,
	0x80, 0x1a, 0x11, 0xb5, 0x3a, 0x46, 0x24, 0x8c, 0x77, 0x56, 0x96, 0xa3, 0x08, 0xe9, 0xad, 0x68,
	0x64, 0xbb, 0xe5, 0xcb, 0x6c, 0xb7, 0xc1, 0xd2, 0x2f, 0x0f, 0x03, 0xf8, 0x43, 0x7c, 0x32, 0x71,
	0x97, 0xb9, 0xfd, 0x80, 0x9a, 0x2c, 0x83, 0xa3, 0x41, 0xe0, 0x05, 0x98, 0x66, 0x29, 0x7a, 0x85,
	0xd3, 0xf6, 0x18, 0x89, 0x7c, 0x93, 0x31, 0x59, 0x05, 0x4d, 0x76, 0x3d, 0xb3, 0xd6, 0x25, 0xe6,
	0x3a, 0x69, 0x8f, 0x9f, 0x5e, 0x6a, 0x8f, 0x93, 0xe9, 0x8d, 0x3a, 0x25, 0xbd, 0xf9, 0x16, 0x96,
	0x42, 0xd3, 0x70, 0x68, 0x87, 0xc1, 0xfb, 0x4e, 0xd4, 0x0f, 0x68, 0xd8, 0xf7, 0x1c, 0x4b, 0x24,
	0x4e, 0x33, 0x22, 0x00, 0xc1, 0x61, 0xbb, 0xde, 0x5b, 0xf7, 0x28, 0x1e, 0x34, 0x3d, 0xfe, 0x2f,
	0xde, 0x28, 0xfe, 0xaf, 0x5d, 0x3b, 0xfe, 0x2f, 0x5d, 0x14, 0xff, 0xd7, 0xa1, 0x62, 0xd1, 0xd0,
	0x0c, 0x6c, 0x9f, 0x1d, 0xa0, 0xb1, 0xcc, 0xef, 0x29, 0x45, 0x62, 0x5e, 0xc1, 0x34, 0xcc, 0xbe,
	0x00, 0xf0, 0xb7, 0xb8, 0x57, 0x40, 0x0a, 0x03, 0xf0, 0x13, 0x01, 0xbe, 0x71, 0x71, 0x80, 0xbf,
	0x3d, 0x2d, 0xc0, 0xdf, 0x49, 0x07, 0xf8, 0x91, 0x33, 0xbc, 0x9b, 0x71, 0x86, 0x1f, 0x43, 0x7d,
	0x60, 0xfc, 0xd0, 0x49, 0x15, 0x12, 0xee, 0x61, 0x40, 0xad, 0x0e, 0x8c, 0x1f, 0xfe, 0x30, 0xae,
	0x25, 0xa4, 0x13, 0xe6, 0xd5, 0x9b, 0x25, 0xcc, 0xd9, 0x44, 0x63, 0xfd, 0xda, 0x89, 0xc6, 0xfd,
	0x1b, 0x25, 0x1a, 0xda, 0x75, 0x12, 0x8d, 0x67, 0x50, 0xe9, 0xd9, 0x51, 0xdf, 0xf3, 0x4e, 0x3b,
	0xc3, 0xc0, 0xe1, 0x10, 0x62, 0xbb, 0xfe, 0xfe, 0xdd, 0x1a, 0xbc, 0xe2, 0xe4, 0x63, 0xfd, 0x40,
	0x07, 0x21, 0x72, 0x1c, 0x38, 0xe3, 0x81, 0xe5, 0xe3, 0xd9, 0x81, 0x05, 0x9f, 0xb8, 0xe1, 0x5a,
	0x27, 0xe7, 0x98, 0x6f, 0xe1, 0x13, 0xc7, 0xee, 0x78, 0x86, 0xf3, 0xc9, 0x55, 0x32, 0x9c, 0x47,
	0x1f, 0x96, 0xe1, 0x3c, 0xbe, 0x7a, 0x86, 0x73, 0xb3, 0x80, 0xc3, 0x0b, 0x44, 0x49, 0x96, 0xb4,
	0xa2, 0xde, 0x6a, 0x49, 0x72, 0x53, 0xbd, 0xa3, 0xbd, 0x4a, 0x67, 0x22, 0x2c, 0xc9, 0x79, 0x01,
	0xb5, 0x04, 0x33, 0xa7, 0x32, 0x9d, 0x85, 0x09, 0x07, 0xa6, 0x57, 0xfd, 0x54, 0x4f, 0xfb, 0xaf,
	0x1c, 0xa8, 0x3b, 0xe8, 0x6a, 0x19, 0x94, 0xe5, 0x6f, 0xfc, 0x46, 0xd5, 0xa2, 0xdb, 0x97, 0x60,
	0xd0, 0xb1, 0x23, 0xe5, 0xd4, 0x7c, 0x4b, 0x92, 0x41, 0xad, 0xf0, 0x8f, 0x86, 0x2d, 0x49, 0x56,
	0x54, 0x68, 0x49, 0xb2, 0xac, 0x2a, 0x2d, 0x49, 0xae, 0xaa, 0xb5, 0x96, 0x24, 0x57, 0xd4, 0x6a,
	0x4b, 0x92, 0x6b, 0x6a, 0xbd, 0x25, 0xc9, 0x75, 0x75, 0xbe, 0x25, 0xc9, 0xcb, 0xea, 0x4a, 0x4b,
	0x92, 0xe7, 0x55, 0xb5, 0x25, 0xc9, 0xaa, 0xba, 0xd0, 0x92, 0xe4, 0x05, 0x95, 0xb4, 0x24, 0x99,
	0xa8, 0x8b, 0x2d, 0x49, 0x5e, 0x54, 0x97, 0x5a, 0x92, 0xbc, 0xa4, 0x2e, 0x27, 0x2a, 0xbb, 0xa5,
	0x36, 0x5a, 0x92, 0xdc, 0x50, 0x6f, 0x6b, 0x7f, 0x96, 0x83, 0x85, 0x7d, 0x97, 0xdd, 0x62, 0x94,
	0x3a, 0xf0, 0xac, 0x32, 0xc7, 0xf5, 0xeb, 0x61, 0x6b, 0x50, 0x39, 0x71, 0x3c, 0xf3, 0xb4, 0x33,
	0x4a, 0x55, 0x65, 0x1d, 0x90, 0x84, 0x4e, 0x5f, 0xfb, 0x9b, 0x1c, 0xd4, 0x0f, 0xec, 0x30, 0xba,
	0x40, 0xe5, 0x97, 0x24, 0x0c, 0x1b, 0x50, 0x45, 0x5f, 0x39, 0x4a, 0xc5, 0x0a, 0x13, 0x90, 0x07,
	0x05, 0xc4, 0x76, 0xae, 0x7d, 0x00, 0xed, 0x0d, 0xcc, 0xbf, 0x74, 0x86, 0x61, 0x3f, 0xb5, 0xbf,
	0x07, 0x50, 0xe6, 0xa3, 0x43, 0x61, 0x59, 0x99, 0xe1, 0x31, 0x8f, 0x7c, 0x0e, 0xd5, 0xc8, 0xeb,
	0xc4, 0x5b, 0x8d, 0x3f, 0xf0, 0x8d, 0x1d, 0xa5, 0x12, 0x79, 0x71, 0x3b, 0xd4, 0x36, 0x40, 0xdd,
	0xa5, 0x0e, 0xcd, 0xd8, 0xdf, 0x8c, 0xeb, 0xd0, 0x9e, 0x42, 0xbd, 0x1d, 0x79, 0xfe, 0x15, 0xa5,
	0xff, 0x33, 0x07, 0xf5, 0x57, 0x34, 0x3a, 0xf0, 0x7a, 0xe1, 0x07, 0x18, 0xf7, 0x2c, 0xb3, 0x88,
	0x2b, 0x06, 0x5d, 0xdb, 0x89, 0x68, 0xc0, 0x73, 0x5c, 0x85, 0x57, 0x0c, 0x5e, 0x72, 0xd2, 0xe8,
	0x6b, 0x57, 0xe9, 0xa2, 0xaf, 0x5d, 0x2b, 0x50, 0x1a, 0x18, 0x61, 0x44, 0x03, 0xcc, 0x6e, 0x65,
	0x5d, 0xf4, 0x18, 0xbd, 0xeb, 0x39, 0x8e, 0xf7, 0x56, 0x7c, 0xa8, 0x16, 0x3d, 0x2c, 0x0f, 0x1b,
	0xb6, 0x23, 0xea, 0x9b, 0xd8, 0xe6, 0x2f, 0x49, 0xfb, 0xe7, 0x3c, 0xc0, 0x81, 0xd7, 0xfb, 0x05,
	0x0d, 0x43, 0xa3, 0x87, 0x69, 0x45, 0xe2, 0x0e, 0x52, 0x38, 0x26, 0x79, 0xfb, 0xaf, 0x19, 0x52,
	0x19, 0xd5, 0xeb, 0x0b, 0x17, 0xd4, 0xeb, 0x33, 0xc5, 0xff, 0xf2, 0xcc, 0xe2, 0xff, 0x43, 0x90,
	0xb9, 0xfb, 0xb5, 0x2d, 0xac, 0x43, 0x29, 0xdb, 0x95, 0xf7, 0xef, 0xd6, 0xca, 0xfc, 0xdb, 0xdf,
	0xae, 0x5e, 0x46, 0xe6, 0xbe, 0x95, 0x3a, 0x32, 0x64, 0x8e, 0x1c, 0x7f, 0x1a, 0x90, 0x66, 0x7c,
	0x1a, 0x88, 0x7f, 0x62, 0xc2, 0x7f, 0x71, 0xc0, 0x7f, 0x62, 0xf2, 0x04, 0xf2, 0x49, 0xd5, 0x7f,
	0x56, 0x42, 0x99, 0x8f, 0x42, 0x16, 0x3c, 0x06, 0x5c, 0x41, 0x78, 0x25, 0x8a, 0x1e, 0x77, 0xb5,
	0x23, 0x58, 0xd4, 0x79, 0xc5, 0x88, 0xdf, 0xcf, 0x15, 0xfc, 0xc2, 0xb8, 0x01, 0xe4, 0x27, 0x0c,
	0x40, 0xfb, 0x1d, 0x58, 0x14, 0xbe, 0x26, 0x33, 0xeb, 0xa5, 0x5f, 0x41, 0xb5, 0x0e, 0xa8, 0xcc,
	0x3f, 0x5c, 0x79, 0x2f, 0x2c, 0x02, 0x19, 0x3d, 0x91, 0x8a, 0xf0, 0xaf, 0x04, 0x32, 0x23, 0x60,
	0x1a, 0x82, 0xdf, 0x79, 0x7b, 0xbc, 0xea, 0x5a, 0xd0, 0xb1, 0xad, 0x9d, 0xc3, 0x42, 0x6a, 0x81,
	0xd0, 0xf7, 0xdc, 0x10, 0x3f, 0x4b, 0x89, 0x2b, 0x64, 0x21, 0x45, 0xbc, 0xf3, 0xfa, 0x68, 0x77,
	0x18, 0x3e, 0x78, 0x44, 0xe5, 0x41, 0x67, 0x0d, 0x2a, 0x58, 0xc5, 0xea, 0xb0, 0x39, 0x43, 0xb1,
	0x30, 0x20, 0xe9, 0x90, 0x51, 0xa6, 0x2e, 0xfd, 0xa7, 0x70, 0x2b, 0x59, 0xba, 0x1d, 0x05, 0xd4,
	0x18, 0x6d, 0xe0, 0x33, 0x80, 0xd1, 0x06, 0x32, 0x1f, 0xdf, 0x46, 0xeb, 0x2b, 0xc9, 0xfa, 0x1f,
	0xb6, 0xfc, 0x36, 0x28, 0x49, 0xce, 0x94, 0xfa, 0xb4, 0x92, 0x4b, 0x7f, 0x5a, 0x61, 0x39, 0x26,
	0x53, 0xa5, 0xf8, 0x6c, 0xc6, 0x27, 0x56, 0x18, 0x85, 0x7f, 0x24, 0xfb, 0xd7, 0x1c, 0xd4, 0xb3,
	0xe9, 0x02, 0x69, 0x41, 0xcd, 0xf5, 0x2c, 0xda, 0x09, 0xa9, 0x43, 0xcd, 0xc8, 0x0b, 0x84, 0xf6,
	0x1e, 0x4c, 0x49, 0x2d, 0x36, 0x5e, 0x7b, 0x16, 0x6d, 0x0b, 0x39, 0x8e, 0x22, 0xaa, 0x6e, 0x8a,
	0x44, 0x36, 0x60, 0xd1, 0x0f, 0x6c, 0x2f, 0xb0, 0xa3, 0xf3, 0x8e, 0xe9, 0x18, 0x61, 0xc8, 0x9f,
	0x30, 0xaf, 0x17, 0x2c, 0xc4, 0xac, 0x1d, 0xc6, 0x61, 0xef, 0xb8, 0xf9, 0x0d, 0x2c, 0x4c, 0x4c,
	0x79, 0xad, 0x5f, 0x4b, 0xfd, 0x8b, 0x02, 0xcb, 0x3c, 0x09, 0x48, 0x9c, 0xe0, 0xf5, 0xc3, 0xd2,
	0xcd, 0xd1, 0x6a, 0xf9, 0x46, 0x68, 0x75, 0xed, 0xba, 0x68, 0x55, 0xb9, 0x18, 0xad, 0xae, 0x40,
	0x69, 0xe8, 0x5b, 0x2c, 0x78, 0x0b, 0xbf, 0xcc, 0x7b, 0x93, 0x68, 0x0d, 0xae, 0x81, 0xd6, 0x2a,
	0xff, 0x6f, 0x68, 0xad, 0x7a, 0x23, 0xb4, 0xb6, 0x72, 0x6d, 0xb4, 0x56, 0xbb, 0x22, 0x5a, 0xab,
	0x5f, 0x86, 0xd6, 0xd4, 0xcb, 0xd0, 0xda, 0xc2, 0x24, 0x5a, 0xbb, 0x0b, 0x4a, 0x40, 0x45, 0xf9,
	0x1e, 0x11, 0xaf, 0xac, 0x8f, 0x08, 0x23, 0xdc, 0xb6, 0x98, 0xc6, 0x6d, 0x93, 0xf8, 0x6c, 0x69,
	0x36, 0x3e, 0x5b, 0xbe, 0x12, 0x3e, 0xbb, 0x7f, 0x35, 0x7c, 0x76, 0xeb, 0xda, 0xf8, 0xac, 0x71,
	0x23, 0x7c, 0x76, 0xfb, 0x3a, 0xf8, 0x2c, 0x06, 0xbf, 0xcd, 0x14, 0xf8, 0x4d, 0x81, 0xaa, 0x3b,
	0x33, 0x41, 0xd5, 0xdd, 0xab, 0x80, 0xaa, 0x7b, 0x1f, 0x06, 0xaa, 0x56, 0x67, 0x80, 0xaa, 0xf5,
	0x89, 0xb2, 0x71, 0x1a, 0x43, 0xcc, 0xab, 0xaa, 0xb6, 0x03, 0x2b, 0x22, 0xd4, 0x7e, 0xb8, 0x0b,
	0xd3, 0x96, 0x61, 0x91, 0x85, 0xa6, 0xb1, 0x19, 0xb4, 0x33, 0x58, 0xe6, 0x29, 0xea, 0x0d, 0xbc,
	0xa3, 0x0a, 0x05, 0xc3, 0x71, 0x44, 0x25, 0x97, 0x35, 0x99, 0xe5, 0x76, 0xbd, 0xc0, 0x8c, 0x5d,
	0x0c, 0xef, 0xb4, 0x24, 0x39, 0xaf, 0x16, 0xc4, 0xef, 0x02, 0xb6, 0x60, 0xa9, 0xcd, 0x52, 0x92,
	0x1b, 0x9c, 0xe8, 0xe7, 0xb0, 0xc8, 0xb2, 0xe5, 0x1b, 0xcc, 0xf0, 0x77, 0x39, 0x20, 0xfa, 0xd0,
	0xbd, 0xc1, 0xd1, 0x3f, 0x05, 0xf0, 0x03, 0xef, 0x8c, 0xba, 0x86, 0x6b, 0xd2, 0x69, 0x68, 0x25,
	0xc5, 0x26, 0x5f, 0xc0, 0x02, 0x77, 0xad, 0x9d, 0xd4, 0x98, 0x42, 0x6a, 0x0c, 0x77, 0xb2, 0xba,
	0xca, 0xa5, 0x0e, 0x13, 0x21, 0xed, 0x4b, 0x58, 0x7e, 0x65, 0x04, 0x27, 0x46, 0x8f, 0xee, 0x78,
	0x0e, 0x8b, 0x84, 0xf1, 0x56, 0xef, 0x43, 0x95, 0xff, 0x44, 0x43, 0x84, 0x73, 0x1e, 0xea, 0x2b,
	0x9c, 0xc6, 0x03, 0x7a, 0x03, 0x56, 0xc6, 0xc7, 0xf2, 0x94, 0x84, 0x99, 0xc4, 0x96, 0x19, 0xd9,
	0x67, 0x46, 0x44, 0xb7, 0x86, 0x51, 0x3f, 0x36, 0x89, 0x15, 0x58, 0xca, 0x92, 0xb9, 0xf8, 0x13,
	0x1f, 0xbf, 0x3b, 0xf0, 0xd2, 0x9e, 0x0a, 0xd5, 0xd6, 0x77, 0xdb, 0x9d, 0xf6, 0xd1, 0x96, 0x7e,
	0xb4, 0xff, 0xfa, 0x95, 0x3a, 0x47, 0xe6, 0xa1, 0xc2, 0x28, 0xfa, 0xf1, 0xeb, 0xd7, 0x8c, 0x90,
	0x8b, 0x09, 0x2f, 0xb7, 0xf6, 0x0f, 0x8e, 0xf5, 0x3d, 0x35, 0x1f, 0x13, 0xda, 0xc7, 0x3b, 0x3b,
	0x7b, 0xed, 0xb6, 0x5a, 0x20, 0x75, 0x00, 0x46, 0xf8, 0x76, 0xff, 0xe0, 0x60, 0x6f, 0x57, 0x95,
	0x62, 0x81, 0x5f, 0xec, 0xe9, 0xaf, 0xd8, 0x14, 0xc5, 0x27, 0xdf, 0x01, 0x8c, 0x7e, 0x1e, 0x47,
	0x00, 0x4a, 0x6c, 0xb2, 0xbd, 0x5d, 0x75, 0x8e, 0x54, 0xa0, 0x1c, 0xcf, 0x93, 0xc3, 0xce, 0xb7,
	0xfb, 0x87, 0x87, 0x7b, 0xbb, 0x6a, 0x9e, 0x54, 0x41, 0x4e, 0x76, 0x55, 0x20, 0x35, 0x50, 0xf4,
	0xbd, 0x9d, 0xef, 0xbe, 0xdf, 0xd3, 0xd9, 0x0a, 0x4f, 0xbe, 0x81, 0x4a, 0xea, 0x83, 0x0a, 0x5b,
	0xf0, 0xf0, 0xbb, 0xdd, 0x64, 0xcf, 0x73, 0x31, 0x61, 0x34, 0x75, 0x1d, 0x80, 0x11, 0xc4, 0xba,
	0xf9, 0x27, 0x7f, 0x99, 0xfa, 0x4c, 0xc2, 0xe7, 0x58, 0x86, 0x85, 0xc3, 0xfd, 0xc3, 0xbd, 0x83,
	0xfd, 0xd7, 0x7b, 0x69, 0x75, 0x2c, 0x81, 0x9a, 0x90, 0x47, 0x3a, 0xb9, 0x05, 0x8b, 0x23, 0xea,
	0x5e, 0x22, 0x9e, 0xcf, 0x88, 0xc7, 0x1a, 0x2b, 0x90, 0x45, 0x98, 0x4f, 0xa8, 0x87, 0x5b, 0xc7,
	0x6d, 0xd4, 0x52, 0x5a, 0xb4, 0x7d, 0xb4, 0xf5, 0x7a, 0x77, 0xfb, 0x8f, 0xd5, 0xe2, 0xe6, 0x7f,
	0x03, 0x14, 0xb6, 0x0e, 0xf7, 0xc9, 0x06, 0x28, 0x49, 0xc9, 0x83, 0x2c, 0x8b, 0x5f, 0x8e, 0x66,
	0x4b, 0x20, 0xcd, 0x24, 0xc1, 0xd6, 0xe6, 0xc8, 0x4f, 0x01, 0x46, 0x25, 0x03, 0xb2, 0x22, 0xc2,
	0xe0, 0x58, 0x0d, 0xa1, 0x99, 0xf9, 0xa8, 0xa4, 0xcd, 0x91, 0x67, 0x50, 0x16, 0x18, 0x9f, 0x70,
	0x5f, 0x98, 0x45, 0xfc, 0xcd, 0x5a, 0x5a, 0x3e, 0xd4, 0xe6, 0x58, 0x46, 0x23, 0x44, 0x78, 0x5a,
	0x3c, 0x7d, 0xd8, 0xd8, 0x32, 0x9f, 0xe7, 0xc8, 0x26, 0xc8, 0x31, 0x5a, 0x27, 0x3c, 0x79, 0x1a,
	0x03, 0xef, 0x53, 0xc6, 0x7c, 0x05, 0x4a, 0x82, 0xba, 0x85, 0x0a, 0xc6, 0x51, 0x78, 0x73, 0x65,
	0x22, 0xa0, 0xec, 0x0d, 0xfc, 0xe8, 0x5c, 0x9b, 0x23, 0x5f, 0x40, 0x59, 0x60, 0x70, 0xb1, 0xc7,
	0x2c, 0x22, 0x9f, 0x31, 0xf2, 0x4b, 0xa8, 0xa6, 0x11, 0x11, 0x69, 0xa4, 0x95, 0x99, 0x86, 0x3b,
	0xcd, 0xb1, 0xbc, 0x5f, 0x9b, 0x63, 0x7b, 0x4e, 0x80, 0x83, 0xd8, 0xf3, 0x38, 0x48, 0x6a, 0xae,
	0x8c, 0x93, 0xc5, 0x33, 0x9e, 0x23, 0x2d, 0x98, 0x1f, 0x83, 0x1d, 0x17, 0xcd, 0x71, 0x37, 0x4b,
	0xce, 0x62, 0x14, 0xd4, 0xde, 0x36, 0xfe, 0x48, 0x2c, 0x41, 0x8b, 0xe2, 0x14, 0x53, 0x00, 0xe4,
	0x0c, 0x4d, 0xbc, 0x84, 0x7a, 0x36, 0xe5, 0x26, 0xcd, 0x94, 0x25, 0x8e, 0xb9, 0xdb, 0x19, 0xf3,
	0xec, 0xc0, 0xfc, 0x58, 0xe0, 0x23, 0x77, 0xd2, 0x4a, 0x1d, 0x9f, 0x69, 0xb2, 0x22, 0xa8, 0xcd,
	0x91, 0xaf, 0xa1, 0x9a, 0x0e, 0x7c, 0xe2, 0x40, 0x53, 0x62, 0x61, 0x93, 0x4c, 0x0c, 0x0f, 0xf9,
	0x61, 0xb2, 0x11, 0x52, 0x1c, 0x66, 0x6a, 0xd8, 0x9c, 0x71, 0x98, 0x5d, 0xa8, 0x65, 0x22, 0x1e,
	0xb9, 0x2d, 0xcc, 0x6b, 0x32, 0x0a, 0xce, 0x98, 0x65, 0x1b, 0xaa, 0xe9, 0xa0, 0x27, 0x4e, 0x33,
	0x25, 0x0e, 0xce, 0x98, 0xe3, 0xe7, 0x50, 0x49, 0x45, 0x3d, 0xc2, 0xff, 0x8d, 0x67, 0x32, 0x0e,
	0xce, 0x98, 0xe1, 0xf7, 0xe3, 0x27, 0xb6, 0xe5, 0x38, 0xe4, 0x02, 0xb1, 0x19, 0xc3, 0x9f, 0x43,
	0x59, 0x14, 0xae, 0xc4, 0x1b, 0xcb, 0x96, 0xb1, 0x9a, 0xfc, 0x97, 0xd1, 0xa3, 0x92, 0x0f, 0x1a,
	0xe6, 0xb7, 0x50, 0xcf, 0xc6, 0x31, 0x71, 0x0f, 0x53, 0x03, 0x63, 0xf3, 0xce, 0x54, 0x5e, 0xf2,
	0x62, 0xf6, 0xa0, 0x9a, 0x8e, 0x71, 0x42, 0x8d, 0x53, 0xa2, 0x61, 0xf3, 0xf6, 0x14, 0x4e, 0x3c,
	0xcd, 0xf6, 0x37, 0xbf, 0x7a, 0xbf, 0x9a, 0xfb, 0xf5, 0xfb, 0xd5, 0xdc, 0xbf, 0xbf, 0x5f, 0xcd,
	0xfd, 0xd5, 0x7f, 0xac, 0xce, 0xfd, 0xc9, 0x67, 0x3d, 0x3b, 0xea, 0x0f, 0x4f, 0x36, 0x4c, 0x6f,
	0xf0, 0xcc, 0x37, 0xcc, 0xfe, 0xb9, 0x45, 0x83, 0x74, 0x2b, 0x0c, 0xcc, 0x67, 0xa3, 0xff, 0x4f,
	0x3b, 0x29, 0xa1, 0x6e, 0x9e, 0xff, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x33, 0xfc, 0x0b, 0xd5,
	0xb4, 0x36, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// APIClient is the client API for API service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type APIClient interface {
	CreateJob(ctx context.Context, in *CreateJobRequest, opts ...grpc.CallOption) (*Job, error)
	InspectJob(ctx context.Context, in *InspectJobRequest, opts ...grpc.CallOption) (*JobInfo, error)
	// ListJob returns information about current and past Pachyderm jobs. This is
	// deprecated in favor of ListJobStream
	ListJob(ctx context.Context, in *ListJobRequest, opts ...grpc.CallOption) (*JobInfos, error)
	// ListJobStream returns information about current and past Pachyderm jobs.
	ListJobStream(ctx context.Context, in *ListJobRequest, opts ...grpc.CallOption) (API_ListJobStreamClient, error)
	FlushJob(ctx context.Context, in *FlushJobRequest, opts ...grpc.CallOption) (API_FlushJobClient, error)
	DeleteJob(ctx context.Context, in *DeleteJobRequest, opts ...grpc.CallOption) (*types.Empty, error)
	StopJob(ctx context.Context, in *StopJobRequest, opts ...grpc.CallOption) (*types.Empty, error)
	InspectDatum(ctx context.Context, in *InspectDatumRequest, opts ...grpc.CallOption) (*DatumInfo, error)
	// ListDatum returns information about each datum fed to a Pachyderm job. This
	// is deprecated in favor of ListDatumStream
	ListDatum(ctx context.Context, in *ListDatumRequest, opts ...grpc.CallOption) (*ListDatumResponse, error)
	// ListDatumStream returns information about each datum fed to a Pachyderm job
	ListDatumStream(ctx context.Context, in *ListDatumRequest, opts ...grpc.CallOption) (API_ListDatumStreamClient, error)
	RestartDatum(ctx context.Context, in *RestartDatumRequest, opts ...grpc.CallOption) (*types.Empty, error)
	CreatePipeline(ctx context.Context, in *CreatePipelineRequest, opts ...grpc.CallOption) (*types.Empty, error)
	InspectPipeline(ctx context.Context, in *InspectPipelineRequest, opts ...grpc.CallOption) (*PipelineInfo, error)
	ListPipeline(ctx context.Context, in *ListPipelineRequest, opts ...grpc.CallOption) (*PipelineInfos, error)
	DeletePipeline(ctx context.Context, in *DeletePipelineRequest, opts ...grpc.CallOption) (*types.Empty, error)
	StartPipeline(ctx context.Context, in *StartPipelineRequest, opts ...grpc.CallOption) (*types.Empty, error)
	StopPipeline(ctx context.Context, in *StopPipelineRequest, opts ...grpc.CallOption) (*types.Empty, error)
	RunPipeline(ctx context.Context, in *RunPipelineRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// DeleteAll deletes everything
	DeleteAll(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*types.Empty, error)
	GetLogs(ctx context.Context, in *GetLogsRequest, opts ...grpc.CallOption) (API_GetLogsClient, error)
	// Garbage collection
	GarbageCollect(ctx context.Context, in *GarbageCollectRequest, opts ...grpc.CallOption) (*GarbageCollectResponse, error)
	// An internal call that causes PPS to put itself into an auth-enabled state
	// (all pipeline have tokens, correct permissions, etcd)
	ActivateAuth(ctx context.Context, in *ActivateAuthRequest, opts ...grpc.CallOption) (*ActivateAuthResponse, error)
}

type aPIClient struct {
	cc *grpc.ClientConn
}

func NewAPIClient(cc *grpc.ClientConn) APIClient {
	return &aPIClient{cc}
}

func (c *aPIClient) CreateJob(ctx context.Context, in *CreateJobRequest, opts ...grpc.CallOption) (*Job, error) {
	out := new(Job)
	err := c.cc.Invoke(ctx, "/pps.API/CreateJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) InspectJob(ctx context.Context, in *InspectJobRequest, opts ...grpc.CallOption) (*JobInfo, error) {
	out := new(JobInfo)
	err := c.cc.Invoke(ctx, "/pps.API/InspectJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListJob(ctx context.Context, in *ListJobRequest, opts ...grpc.CallOption) (*JobInfos, error) {
	out := new(JobInfos)
	err := c.cc.Invoke(ctx, "/pps.API/ListJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListJobStream(ctx context.Context, in *ListJobRequest, opts ...grpc.CallOption) (API_ListJobStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[0], "/pps.API/ListJobStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIListJobStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_ListJobStreamClient interface {
	Recv() (*JobInfo, error)
	grpc.ClientStream
}

type aPIListJobStreamClient struct {
	grpc.ClientStream
}

func (x *aPIListJobStreamClient) Recv() (*JobInfo, error) {
	m := new(JobInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) FlushJob(ctx context.Context, in *FlushJobRequest, opts ...grpc.CallOption) (API_FlushJobClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[1], "/pps.API/FlushJob", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIFlushJobClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_FlushJobClient interface {
	Recv() (*JobInfo, error)
	grpc.ClientStream
}

type aPIFlushJobClient struct {
	grpc.ClientStream
}

func (x *aPIFlushJobClient) Recv() (*JobInfo, error) {
	m := new(JobInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) DeleteJob(ctx context.Context, in *DeleteJobRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pps.API/DeleteJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) StopJob(ctx context.Context, in *StopJobRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pps.API/StopJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) InspectDatum(ctx context.Context, in *InspectDatumRequest, opts ...grpc.CallOption) (*DatumInfo, error) {
	out := new(DatumInfo)
	err := c.cc.Invoke(ctx, "/pps.API/InspectDatum", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListDatum(ctx context.Context, in *ListDatumRequest, opts ...grpc.CallOption) (*ListDatumResponse, error) {
	out := new(ListDatumResponse)
	err := c.cc.Invoke(ctx, "/pps.API/ListDatum", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListDatumStream(ctx context.Context, in *ListDatumRequest, opts ...grpc.CallOption) (API_ListDatumStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[2], "/pps.API/ListDatumStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIListDatumStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_ListDatumStreamClient interface {
	Recv() (*ListDatumStreamResponse, error)
	grpc.ClientStream
}

type aPIListDatumStreamClient struct {
	grpc.ClientStream
}

func (x *aPIListDatumStreamClient) Recv() (*ListDatumStreamResponse, error) {
	m := new(ListDatumStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) RestartDatum(ctx context.Context, in *RestartDatumRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pps.API/RestartDatum", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) CreatePipeline(ctx context.Context, in *CreatePipelineRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pps.API/CreatePipeline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) InspectPipeline(ctx context.Context, in *InspectPipelineRequest, opts ...grpc.CallOption) (*PipelineInfo, error) {
	out := new(PipelineInfo)
	err := c.cc.Invoke(ctx, "/pps.API/InspectPipeline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListPipeline(ctx context.Context, in *ListPipelineRequest, opts ...grpc.CallOption) (*PipelineInfos, error) {
	out := new(PipelineInfos)
	err := c.cc.Invoke(ctx, "/pps.API/ListPipeline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) DeletePipeline(ctx context.Context, in *DeletePipelineRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pps.API/DeletePipeline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) StartPipeline(ctx context.Context, in *StartPipelineRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pps.API/StartPipeline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) StopPipeline(ctx context.Context, in *StopPipelineRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pps.API/StopPipeline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) RunPipeline(ctx context.Context, in *RunPipelineRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pps.API/RunPipeline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) DeleteAll(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pps.API/DeleteAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) GetLogs(ctx context.Context, in *GetLogsRequest, opts ...grpc.CallOption) (API_GetLogsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[3], "/pps.API/GetLogs", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIGetLogsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_GetLogsClient interface {
	Recv() (*LogMessage, error)
	grpc.ClientStream
}

type aPIGetLogsClient struct {
	grpc.ClientStream
}

func (x *aPIGetLogsClient) Recv() (*LogMessage, error) {
	m := new(LogMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) GarbageCollect(ctx context.Context, in *GarbageCollectRequest, opts ...grpc.CallOption) (*GarbageCollectResponse, error) {
	out := new(GarbageCollectResponse)
	err := c.cc.Invoke(ctx, "/pps.API/GarbageCollect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ActivateAuth(ctx context.Context, in *ActivateAuthRequest, opts ...grpc.CallOption) (*ActivateAuthResponse, error) {
	out := new(ActivateAuthResponse)
	err := c.cc.Invoke(ctx, "/pps.API/ActivateAuth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// APIServer is the server API for API service.
type APIServer interface {
	CreateJob(context.Context, *CreateJobRequest) (*Job, error)
	InspectJob(context.Context, *InspectJobRequest) (*JobInfo, error)
	// ListJob returns information about current and past Pachyderm jobs. This is
	// deprecated in favor of ListJobStream
	ListJob(context.Context, *ListJobRequest) (*JobInfos, error)
	// ListJobStream returns information about current and past Pachyderm jobs.
	ListJobStream(*ListJobRequest, API_ListJobStreamServer) error
	FlushJob(*FlushJobRequest, API_FlushJobServer) error
	DeleteJob(context.Context, *DeleteJobRequest) (*types.Empty, error)
	StopJob(context.Context, *StopJobRequest) (*types.Empty, error)
	InspectDatum(context.Context, *InspectDatumRequest) (*DatumInfo, error)
	// ListDatum returns information about each datum fed to a Pachyderm job. This
	// is deprecated in favor of ListDatumStream
	ListDatum(context.Context, *ListDatumRequest) (*ListDatumResponse, error)
	// ListDatumStream returns information about each datum fed to a Pachyderm job
	ListDatumStream(*ListDatumRequest, API_ListDatumStreamServer) error
	RestartDatum(context.Context, *RestartDatumRequest) (*types.Empty, error)
	CreatePipeline(context.Context, *CreatePipelineRequest) (*types.Empty, error)
	InspectPipeline(context.Context, *InspectPipelineRequest) (*PipelineInfo, error)
	ListPipeline(context.Context, *ListPipelineRequest) (*PipelineInfos, error)
	DeletePipeline(context.Context, *DeletePipelineRequest) (*types.Empty, error)
	StartPipeline(context.Context, *StartPipelineRequest) (*types.Empty, error)
	StopPipeline(context.Context, *StopPipelineRequest) (*types.Empty, error)
	RunPipeline(context.Context, *RunPipelineRequest) (*types.Empty, error)
	// DeleteAll deletes everything
	DeleteAll(context.Context, *types.Empty) (*types.Empty, error)
	GetLogs(*GetLogsRequest, API_GetLogsServer) error
	// Garbage collection
	GarbageCollect(context.Context, *GarbageCollectRequest) (*GarbageCollectResponse, error)
	// An internal call that causes PPS to put itself into an auth-enabled state
	// (all pipeline have tokens, correct permissions, etcd)
	ActivateAuth(context.Context, *ActivateAuthRequest) (*ActivateAuthResponse, error)
}

func RegisterAPIServer(s *grpc.Server, srv APIServer) {
	s.RegisterService(&_API_serviceDesc, srv)
}

func _API_CreateJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CreateJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/CreateJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CreateJob(ctx, req.(*CreateJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_InspectJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/InspectJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectJob(ctx, req.(*InspectJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ListJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/ListJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ListJob(ctx, req.(*ListJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListJobStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListJobRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).ListJobStream(m, &aPIListJobStreamServer{stream})
}

type API_ListJobStreamServer interface {
	Send(*JobInfo) error
	grpc.ServerStream
}

type aPIListJobStreamServer struct {
	grpc.ServerStream
}

func (x *aPIListJobStreamServer) Send(m *JobInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_FlushJob_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FlushJobRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).FlushJob(m, &aPIFlushJobServer{stream})
}

type API_FlushJobServer interface {
	Send(*JobInfo) error
	grpc.ServerStream
}

type aPIFlushJobServer struct {
	grpc.ServerStream
}

func (x *aPIFlushJobServer) Send(m *JobInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_DeleteJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeleteJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/DeleteJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeleteJob(ctx, req.(*DeleteJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_StopJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).StopJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/StopJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).StopJob(ctx, req.(*StopJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_InspectDatum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectDatumRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectDatum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/InspectDatum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectDatum(ctx, req.(*InspectDatumRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListDatum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDatumRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ListDatum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/ListDatum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ListDatum(ctx, req.(*ListDatumRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListDatumStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListDatumRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).ListDatumStream(m, &aPIListDatumStreamServer{stream})
}

type API_ListDatumStreamServer interface {
	Send(*ListDatumStreamResponse) error
	grpc.ServerStream
}

type aPIListDatumStreamServer struct {
	grpc.ServerStream
}

func (x *aPIListDatumStreamServer) Send(m *ListDatumStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _API_RestartDatum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestartDatumRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).RestartDatum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/RestartDatum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).RestartDatum(ctx, req.(*RestartDatumRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_CreatePipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CreatePipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/CreatePipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CreatePipeline(ctx, req.(*CreatePipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_InspectPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectPipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/InspectPipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectPipeline(ctx, req.(*InspectPipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ListPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/ListPipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ListPipeline(ctx, req.(*ListPipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_DeletePipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeletePipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/DeletePipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeletePipeline(ctx, req.(*DeletePipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_StartPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartPipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).StartPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/StartPipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).StartPipeline(ctx, req.(*StartPipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_StopPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopPipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).StopPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/StopPipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).StopPipeline(ctx, req.(*StopPipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_RunPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunPipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).RunPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/RunPipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).RunPipeline(ctx, req.(*RunPipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_DeleteAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeleteAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/DeleteAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeleteAll(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_GetLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetLogsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).GetLogs(m, &aPIGetLogsServer{stream})
}

type API_GetLogsServer interface {
	Send(*LogMessage) error
	grpc.ServerStream
}

type aPIGetLogsServer struct {
	grpc.ServerStream
}

func (x *aPIGetLogsServer) Send(m *LogMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _API_GarbageCollect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GarbageCollectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).GarbageCollect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/GarbageCollect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).GarbageCollect(ctx, req.(*GarbageCollectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ActivateAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActivateAuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ActivateAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/ActivateAuth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ActivateAuth(ctx, req.(*ActivateAuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _API_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pps.API",
	HandlerType: (*APIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateJob",
			Handler:    _API_CreateJob_Handler,
		},
		{
			MethodName: "InspectJob",
			Handler:    _API_InspectJob_Handler,
		},
		{
			MethodName: "ListJob",
			Handler:    _API_ListJob_Handler,
		},
		{
			MethodName: "DeleteJob",
			Handler:    _API_DeleteJob_Handler,
		},
		{
			MethodName: "StopJob",
			Handler:    _API_StopJob_Handler,
		},
		{
			MethodName: "InspectDatum",
			Handler:    _API_InspectDatum_Handler,
		},
		{
			MethodName: "ListDatum",
			Handler:    _API_ListDatum_Handler,
		},
		{
			MethodName: "RestartDatum",
			Handler:    _API_RestartDatum_Handler,
		},
		{
			MethodName: "CreatePipeline",
			Handler:    _API_CreatePipeline_Handler,
		},
		{
			MethodName: "InspectPipeline",
			Handler:    _API_InspectPipeline_Handler,
		},
		{
			MethodName: "ListPipeline",
			Handler:    _API_ListPipeline_Handler,
		},
		{
			MethodName: "DeletePipeline",
			Handler:    _API_DeletePipeline_Handler,
		},
		{
			MethodName: "StartPipeline",
			Handler:    _API_StartPipeline_Handler,
		},
		{
			MethodName: "StopPipeline",
			Handler:    _API_StopPipeline_Handler,
		},
		{
			MethodName: "RunPipeline",
			Handler:    _API_RunPipeline_Handler,
		},
		{
			MethodName: "DeleteAll",
			Handler:    _API_DeleteAll_Handler,
		},
		{
			MethodName: "GarbageCollect",
			Handler:    _API_GarbageCollect_Handler,
		},
		{
			MethodName: "ActivateAuth",
			Handler:    _API_ActivateAuth_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListJobStream",
			Handler:       _API_ListJobStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "FlushJob",
			Handler:       _API_FlushJob_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListDatumStream",
			Handler:       _API_ListDatumStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetLogs",
			Handler:       _API_GetLogs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "client/pps/pps.proto",
}

func (m *Secret) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Secret) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.MountPath) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.MountPath)))
		i += copy(dAtA[i:], m.MountPath)
	}
	if len(m.EnvVar) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.EnvVar)))
		i += copy(dAtA[i:], m.EnvVar)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Transform) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transform) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Image) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.Cmd) > 0 {
		for _, s := range m.Cmd {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Env) > 0 {
		for k, _ := range m.Env {
			dAtA[i] = 0x1a
			i++
			v := m.Env[k]
			mapSize := 1 + len(k) + sovPps(uint64(len(k))) + 1 + len(v) + sovPps(uint64(len(v)))
			i = encodeVarintPps(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPps(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintPps(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Secrets) > 0 {
		for _, msg := range m.Secrets {
			dAtA[i] = 0x22
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Stdin) > 0 {
		for _, s := range m.Stdin {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.AcceptReturnCode) > 0 {
		dAtA2 := make([]byte, len(m.AcceptReturnCode)*10)
		var j1 int
		for _, num1 := range m.AcceptReturnCode {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintPps(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if m.Debug {
		dAtA[i] = 0x38
		i++
		if m.Debug {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ImagePullSecrets) > 0 {
		for _, s := range m.ImagePullSecrets {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.User) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	if len(m.WorkingDir) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.WorkingDir)))
		i += copy(dAtA[i:], m.WorkingDir)
	}
	if len(m.Dockerfile) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Dockerfile)))
		i += copy(dAtA[i:], m.Dockerfile)
	}
	if len(m.ErrCmd) > 0 {
		for _, s := range m.ErrCmd {
			dAtA[i] = 0x6a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ErrStdin) > 0 {
		for _, s := range m.ErrStdin {
			dAtA[i] = 0x72
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Egress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Egress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URL) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.URL)))
		i += copy(dAtA[i:], m.URL)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Job) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Job) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Service) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Service) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InternalPort != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.InternalPort))
	}
	if m.ExternalPort != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ExternalPort))
	}
	if len(m.IP) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.IP)))
		i += copy(dAtA[i:], m.IP)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Spout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Spout) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Overwrite {
		dAtA[i] = 0x8
		i++
		if m.Overwrite {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AtomInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AtomInput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Repo) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Repo)))
		i += copy(dAtA[i:], m.Repo)
	}
	if len(m.Branch) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Branch)))
		i += copy(dAtA[i:], m.Branch)
	}
	if len(m.Commit) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Commit)))
		i += copy(dAtA[i:], m.Commit)
	}
	if len(m.Glob) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Glob)))
		i += copy(dAtA[i:], m.Glob)
	}
	if m.Lazy {
		dAtA[i] = 0x30
		i++
		if m.Lazy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EmptyFiles {
		dAtA[i] = 0x40
		i++
		if m.EmptyFiles {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PFSInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PFSInput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Repo) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Repo)))
		i += copy(dAtA[i:], m.Repo)
	}
	if len(m.Branch) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Branch)))
		i += copy(dAtA[i:], m.Branch)
	}
	if len(m.Commit) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Commit)))
		i += copy(dAtA[i:], m.Commit)
	}
	if len(m.Glob) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Glob)))
		i += copy(dAtA[i:], m.Glob)
	}
	if m.Lazy {
		dAtA[i] = 0x30
		i++
		if m.Lazy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EmptyFiles {
		dAtA[i] = 0x38
		i++
		if m.EmptyFiles {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CronInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CronInput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Repo) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Repo)))
		i += copy(dAtA[i:], m.Repo)
	}
	if len(m.Commit) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Commit)))
		i += copy(dAtA[i:], m.Commit)
	}
	if len(m.Spec) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Spec)))
		i += copy(dAtA[i:], m.Spec)
	}
	if m.Start != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Start.Size()))
		n3, err3 := m.Start.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	if m.Overwrite {
		dAtA[i] = 0x30
		i++
		if m.Overwrite {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GitInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GitInput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.URL) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.URL)))
		i += copy(dAtA[i:], m.URL)
	}
	if len(m.Branch) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Branch)))
		i += copy(dAtA[i:], m.Branch)
	}
	if len(m.Commit) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Commit)))
		i += copy(dAtA[i:], m.Commit)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Input) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Input) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Atom != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Atom.Size()))
		n4, err4 := m.Atom.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	if len(m.Cross) > 0 {
		for _, msg := range m.Cross {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Union) > 0 {
		for _, msg := range m.Union {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Cron != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Cron.Size()))
		n5, err5 := m.Cron.MarshalTo(dAtA[i:])
		if err5 != nil {
			return 0, err5
		}
		i += n5
	}
	if m.Git != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Git.Size()))
		n6, err6 := m.Git.MarshalTo(dAtA[i:])
		if err6 != nil {
			return 0, err6
		}
		i += n6
	}
	if m.Pfs != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pfs.Size()))
		n7, err7 := m.Pfs.MarshalTo(dAtA[i:])
		if err7 != nil {
			return 0, err7
		}
		i += n7
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *JobInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobInput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Commit != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Commit.Size()))
		n8, err8 := m.Commit.MarshalTo(dAtA[i:])
		if err8 != nil {
			return 0, err8
		}
		i += n8
	}
	if len(m.Glob) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Glob)))
		i += copy(dAtA[i:], m.Glob)
	}
	if m.Lazy {
		dAtA[i] = 0x18
		i++
		if m.Lazy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ParallelismSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParallelismSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Constant != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Constant))
	}
	if m.Coefficient != 0 {
		dAtA[i] = 0x19
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Coefficient))))
		i += 8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HashtreeSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HashtreeSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Constant != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Constant))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InputFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputFile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if len(m.Hash) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Datum) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Datum) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if m.Job != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Job.Size()))
		n9, err9 := m.Job.MarshalTo(dAtA[i:])
		if err9 != nil {
			return 0, err9
		}
		i += n9
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DatumInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatumInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Datum != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Datum.Size()))
		n10, err10 := m.Datum.MarshalTo(dAtA[i:])
		if err10 != nil {
			return 0, err10
		}
		i += n10
	}
	if m.State != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.State))
	}
	if m.Stats != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Stats.Size()))
		n11, err11 := m.Stats.MarshalTo(dAtA[i:])
		if err11 != nil {
			return 0, err11
		}
		i += n11
	}
	if m.PfsState != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.PfsState.Size()))
		n12, err12 := m.PfsState.MarshalTo(dAtA[i:])
		if err12 != nil {
			return 0, err12
		}
		i += n12
	}
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Aggregate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Aggregate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Count))
	}
	if m.Mean != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Mean))))
		i += 8
	}
	if m.Stddev != 0 {
		dAtA[i] = 0x19
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Stddev))))
		i += 8
	}
	if m.FifthPercentile != 0 {
		dAtA[i] = 0x21
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FifthPercentile))))
		i += 8
	}
	if m.NinetyFifthPercentile != 0 {
		dAtA[i] = 0x29
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.NinetyFifthPercentile))))
		i += 8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProcessStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DownloadTime != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DownloadTime.Size()))
		n13, err13 := m.DownloadTime.MarshalTo(dAtA[i:])
		if err13 != nil {
			return 0, err13
		}
		i += n13
	}
	if m.ProcessTime != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ProcessTime.Size()))
		n14, err14 := m.ProcessTime.MarshalTo(dAtA[i:])
		if err14 != nil {
			return 0, err14
		}
		i += n14
	}
	if m.UploadTime != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.UploadTime.Size()))
		n15, err15 := m.UploadTime.MarshalTo(dAtA[i:])
		if err15 != nil {
			return 0, err15
		}
		i += n15
	}
	if m.DownloadBytes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DownloadBytes))
	}
	if m.UploadBytes != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.UploadBytes))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AggregateProcessStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AggregateProcessStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DownloadTime != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DownloadTime.Size()))
		n16, err16 := m.DownloadTime.MarshalTo(dAtA[i:])
		if err16 != nil {
			return 0, err16
		}
		i += n16
	}
	if m.ProcessTime != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ProcessTime.Size()))
		n17, err17 := m.ProcessTime.MarshalTo(dAtA[i:])
		if err17 != nil {
			return 0, err17
		}
		i += n17
	}
	if m.UploadTime != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.UploadTime.Size()))
		n18, err18 := m.UploadTime.MarshalTo(dAtA[i:])
		if err18 != nil {
			return 0, err18
		}
		i += n18
	}
	if m.DownloadBytes != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DownloadBytes.Size()))
		n19, err19 := m.DownloadBytes.MarshalTo(dAtA[i:])
		if err19 != nil {
			return 0, err19
		}
		i += n19
	}
	if m.UploadBytes != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.UploadBytes.Size()))
		n20, err20 := m.UploadBytes.MarshalTo(dAtA[i:])
		if err20 != nil {
			return 0, err20
		}
		i += n20
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WorkerStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.WorkerID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.WorkerID)))
		i += copy(dAtA[i:], m.WorkerID)
	}
	if len(m.JobID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.JobID)))
		i += copy(dAtA[i:], m.JobID)
	}
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Started != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Started.Size()))
		n21, err21 := m.Started.MarshalTo(dAtA[i:])
		if err21 != nil {
			return 0, err21
		}
		i += n21
	}
	if m.Stats != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Stats.Size()))
		n22, err22 := m.Stats.MarshalTo(dAtA[i:])
		if err22 != nil {
			return 0, err22
		}
		i += n22
	}
	if m.QueueSize != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.QueueSize))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResourceSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cpu != 0 {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Cpu))))
		i += 4
	}
	if len(m.Memory) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Memory)))
		i += copy(dAtA[i:], m.Memory)
	}
	if len(m.Disk) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Disk)))
		i += copy(dAtA[i:], m.Disk)
	}
	if m.Gpu != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Gpu.Size()))
		n23, err23 := m.Gpu.MarshalTo(dAtA[i:])
		if err23 != nil {
			return 0, err23
		}
		i += n23
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GPUSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPUSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Number != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Number))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EtcdJobInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EtcdJobInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Job != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Job.Size()))
		n24, err24 := m.Job.MarshalTo(dAtA[i:])
		if err24 != nil {
			return 0, err24
		}
		i += n24
	}
	if m.Pipeline != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n25, err25 := m.Pipeline.MarshalTo(dAtA[i:])
		if err25 != nil {
			return 0, err25
		}
		i += n25
	}
	if m.OutputCommit != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.OutputCommit.Size()))
		n26, err26 := m.OutputCommit.MarshalTo(dAtA[i:])
		if err26 != nil {
			return 0, err26
		}
		i += n26
	}
	if m.Restart != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Restart))
	}
	if m.DataProcessed != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DataProcessed))
	}
	if m.DataSkipped != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DataSkipped))
	}
	if m.DataTotal != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DataTotal))
	}
	if m.DataFailed != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DataFailed))
	}
	if m.Stats != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Stats.Size()))
		n27, err27 := m.Stats.MarshalTo(dAtA[i:])
		if err27 != nil {
			return 0, err27
		}
		i += n27
	}
	if m.StatsCommit != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.StatsCommit.Size()))
		n28, err28 := m.StatsCommit.MarshalTo(dAtA[i:])
		if err28 != nil {
			return 0, err28
		}
		i += n28
	}
	if m.State != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.State))
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if m.Started != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Started.Size()))
		n29, err29 := m.Started.MarshalTo(dAtA[i:])
		if err29 != nil {
			return 0, err29
		}
		i += n29
	}
	if m.Finished != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Finished.Size()))
		n30, err30 := m.Finished.MarshalTo(dAtA[i:])
		if err30 != nil {
			return 0, err30
		}
		i += n30
	}
	if m.DataRecovered != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DataRecovered))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *JobInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Job != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Job.Size()))
		n31, err31 := m.Job.MarshalTo(dAtA[i:])
		if err31 != nil {
			return 0, err31
		}
		i += n31
	}
	if m.Transform != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Transform.Size()))
		n32, err32 := m.Transform.MarshalTo(dAtA[i:])
		if err32 != nil {
			return 0, err32
		}
		i += n32
	}
	if m.Pipeline != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n33, err33 := m.Pipeline.MarshalTo(dAtA[i:])
		if err33 != nil {
			return 0, err33
		}
		i += n33
	}
	if m.ParentJob != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ParentJob.Size()))
		n34, err34 := m.ParentJob.MarshalTo(dAtA[i:])
		if err34 != nil {
			return 0, err34
		}
		i += n34
	}
	if m.Started != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Started.Size()))
		n35, err35 := m.Started.MarshalTo(dAtA[i:])
		if err35 != nil {
			return 0, err35
		}
		i += n35
	}
	if m.Finished != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Finished.Size()))
		n36, err36 := m.Finished.MarshalTo(dAtA[i:])
		if err36 != nil {
			return 0, err36
		}
		i += n36
	}
	if m.OutputCommit != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.OutputCommit.Size()))
		n37, err37 := m.OutputCommit.MarshalTo(dAtA[i:])
		if err37 != nil {
			return 0, err37
		}
		i += n37
	}
	if m.State != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.State))
	}
	if m.ParallelismSpec != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ParallelismSpec.Size()))
		n38, err38 := m.ParallelismSpec.MarshalTo(dAtA[i:])
		if err38 != nil {
			return 0, err38
		}
		i += n38
	}
	if m.PipelineVersion != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.PipelineVersion))
	}
	if m.Service != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Service.Size()))
		n39, err39 := m.Service.MarshalTo(dAtA[i:])
		if err39 != nil {
			return 0, err39
		}
		i += n39
	}
	if m.Egress != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Egress.Size()))
		n40, err40 := m.Egress.MarshalTo(dAtA[i:])
		if err40 != nil {
			return 0, err40
		}
		i += n40
	}
	if len(m.OutputBranch) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.OutputBranch)))
		i += copy(dAtA[i:], m.OutputBranch)
	}
	if m.OutputRepo != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.OutputRepo.Size()))
		n41, err41 := m.OutputRepo.MarshalTo(dAtA[i:])
		if err41 != nil {
			return 0, err41
		}
		i += n41
	}
	if m.Restart != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Restart))
	}
	if m.DataProcessed != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DataProcessed))
	}
	if m.DataTotal != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DataTotal))
	}
	if len(m.WorkerStatus) > 0 {
		for _, msg := range m.WorkerStatus {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ResourceRequests != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ResourceRequests.Size()))
		n42, err42 := m.ResourceRequests.MarshalTo(dAtA[i:])
		if err42 != nil {
			return 0, err42
		}
		i += n42
	}
	if m.Input != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Input.Size()))
		n43, err43 := m.Input.MarshalTo(dAtA[i:])
		if err43 != nil {
			return 0, err43
		}
		i += n43
	}
	if m.NewBranch != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.NewBranch.Size()))
		n44, err44 := m.NewBranch.MarshalTo(dAtA[i:])
		if err44 != nil {
			return 0, err44
		}
		i += n44
	}
	if m.StatsCommit != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.StatsCommit.Size()))
		n45, err45 := m.StatsCommit.MarshalTo(dAtA[i:])
		if err45 != nil {
			return 0, err45
		}
		i += n45
	}
	if m.DataSkipped != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DataSkipped))
	}
	if m.Stats != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Stats.Size()))
		n46, err46 := m.Stats.MarshalTo(dAtA[i:])
		if err46 != nil {
			return 0, err46
		}
		i += n46
	}
	if m.EnableStats {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		if m.EnableStats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Salt) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Salt)))
		i += copy(dAtA[i:], m.Salt)
	}
	if m.Batch {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		if m.Batch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if m.ResourceLimits != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ResourceLimits.Size()))
		n47, err47 := m.ResourceLimits.MarshalTo(dAtA[i:])
		if err47 != nil {
			return 0, err47
		}
		i += n47
	}
	if m.ChunkSpec != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ChunkSpec.Size()))
		n48, err48 := m.ChunkSpec.MarshalTo(dAtA[i:])
		if err48 != nil {
			return 0, err48
		}
		i += n48
	}
	if m.DatumTimeout != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DatumTimeout.Size()))
		n49, err49 := m.DatumTimeout.MarshalTo(dAtA[i:])
		if err49 != nil {
			return 0, err49
		}
		i += n49
	}
	if m.JobTimeout != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.JobTimeout.Size()))
		n50, err50 := m.JobTimeout.MarshalTo(dAtA[i:])
		if err50 != nil {
			return 0, err50
		}
		i += n50
	}
	if m.DataFailed != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DataFailed))
	}
	if m.DatumTries != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DatumTries))
	}
	if m.SchedulingSpec != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.SchedulingSpec.Size()))
		n51, err51 := m.SchedulingSpec.MarshalTo(dAtA[i:])
		if err51 != nil {
			return 0, err51
		}
		i += n51
	}
	if len(m.PodSpec) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.PodSpec)))
		i += copy(dAtA[i:], m.PodSpec)
	}
	if len(m.PodPatch) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.PodPatch)))
		i += copy(dAtA[i:], m.PodPatch)
	}
	if m.Spout != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Spout.Size()))
		n52, err52 := m.Spout.MarshalTo(dAtA[i:])
		if err52 != nil {
			return 0, err52
		}
		i += n52
	}
	if m.DataRecovered != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DataRecovered))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Worker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Worker) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.State != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *JobInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobInfos) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.JobInfo) > 0 {
		for _, msg := range m.JobInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Pipeline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pipeline) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PipelineInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PipelineInput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Repo.Size()))
		n53, err53 := m.Repo.MarshalTo(dAtA[i:])
		if err53 != nil {
			return 0, err53
		}
		i += n53
	}
	if len(m.Branch) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Branch)))
		i += copy(dAtA[i:], m.Branch)
	}
	if len(m.Glob) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Glob)))
		i += copy(dAtA[i:], m.Glob)
	}
	if m.Lazy {
		dAtA[i] = 0x20
		i++
		if m.Lazy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.From != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.From.Size()))
		n54, err54 := m.From.MarshalTo(dAtA[i:])
		if err54 != nil {
			return 0, err54
		}
		i += n54
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EtcdPipelineInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EtcdPipelineInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.State))
	}
	if m.SpecCommit != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.SpecCommit.Size()))
		n55, err55 := m.SpecCommit.MarshalTo(dAtA[i:])
		if err55 != nil {
			return 0, err55
		}
		i += n55
	}
	if len(m.JobCounts) > 0 {
		for k, _ := range m.JobCounts {
			dAtA[i] = 0x1a
			i++
			v := m.JobCounts[k]
			mapSize := 1 + sovPps(uint64(k)) + 1 + sovPps(uint64(v))
			i = encodeVarintPps(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintPps(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintPps(dAtA, i, uint64(v))
		}
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if len(m.AuthToken) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.AuthToken)))
		i += copy(dAtA[i:], m.AuthToken)
	}
	if m.LastJobState != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.LastJobState))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PipelineInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PipelineInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pipeline != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n56, err56 := m.Pipeline.MarshalTo(dAtA[i:])
		if err56 != nil {
			return 0, err56
		}
		i += n56
	}
	if m.Transform != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Transform.Size()))
		n57, err57 := m.Transform.MarshalTo(dAtA[i:])
		if err57 != nil {
			return 0, err57
		}
		i += n57
	}
	if m.CreatedAt != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.CreatedAt.Size()))
		n58, err58 := m.CreatedAt.MarshalTo(dAtA[i:])
		if err58 != nil {
			return 0, err58
		}
		i += n58
	}
	if m.State != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.State))
	}
	if len(m.RecentError) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.RecentError)))
		i += copy(dAtA[i:], m.RecentError)
	}
	if len(m.JobCounts) > 0 {
		for k, _ := range m.JobCounts {
			dAtA[i] = 0x4a
			i++
			v := m.JobCounts[k]
			mapSize := 1 + sovPps(uint64(k)) + 1 + sovPps(uint64(v))
			i = encodeVarintPps(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintPps(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintPps(dAtA, i, uint64(v))
		}
	}
	if m.ParallelismSpec != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ParallelismSpec.Size()))
		n59, err59 := m.ParallelismSpec.MarshalTo(dAtA[i:])
		if err59 != nil {
			return 0, err59
		}
		i += n59
	}
	if m.Version != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Version))
	}
	if m.Egress != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Egress.Size()))
		n60, err60 := m.Egress.MarshalTo(dAtA[i:])
		if err60 != nil {
			return 0, err60
		}
		i += n60
	}
	if len(m.OutputBranch) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.OutputBranch)))
		i += copy(dAtA[i:], m.OutputBranch)
	}
	if len(m.ID) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if m.ScaleDownThreshold != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ScaleDownThreshold.Size()))
		n61, err61 := m.ScaleDownThreshold.MarshalTo(dAtA[i:])
		if err61 != nil {
			return 0, err61
		}
		i += n61
	}
	if m.ResourceRequests != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ResourceRequests.Size()))
		n62, err62 := m.ResourceRequests.MarshalTo(dAtA[i:])
		if err62 != nil {
			return 0, err62
		}
		i += n62
	}
	if m.Input != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Input.Size()))
		n63, err63 := m.Input.MarshalTo(dAtA[i:])
		if err63 != nil {
			return 0, err63
		}
		i += n63
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.CacheSize) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.CacheSize)))
		i += copy(dAtA[i:], m.CacheSize)
	}
	if m.EnableStats {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		if m.EnableStats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Salt) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Salt)))
		i += copy(dAtA[i:], m.Salt)
	}
	if m.Batch {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		if m.Batch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if m.MaxQueueSize != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.MaxQueueSize))
	}
	if m.Service != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Service.Size()))
		n64, err64 := m.Service.MarshalTo(dAtA[i:])
		if err64 != nil {
			return 0, err64
		}
		i += n64
	}
	if m.ResourceLimits != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ResourceLimits.Size()))
		n65, err65 := m.ResourceLimits.MarshalTo(dAtA[i:])
		if err65 != nil {
			return 0, err65
		}
		i += n65
	}
	if m.ChunkSpec != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ChunkSpec.Size()))
		n66, err66 := m.ChunkSpec.MarshalTo(dAtA[i:])
		if err66 != nil {
			return 0, err66
		}
		i += n66
	}
	if m.DatumTimeout != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DatumTimeout.Size()))
		n67, err67 := m.DatumTimeout.MarshalTo(dAtA[i:])
		if err67 != nil {
			return 0, err67
		}
		i += n67
	}
	if m.JobTimeout != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.JobTimeout.Size()))
		n68, err68 := m.JobTimeout.MarshalTo(dAtA[i:])
		if err68 != nil {
			return 0, err68
		}
		i += n68
	}
	if len(m.GithookURL) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.GithookURL)))
		i += copy(dAtA[i:], m.GithookURL)
	}
	if m.SpecCommit != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.SpecCommit.Size()))
		n69, err69 := m.SpecCommit.MarshalTo(dAtA[i:])
		if err69 != nil {
			return 0, err69
		}
		i += n69
	}
	if m.Standby {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x2
		i++
		if m.Standby {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Stopped {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		if m.Stopped {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DatumTries != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DatumTries))
	}
	if m.SchedulingSpec != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.SchedulingSpec.Size()))
		n70, err70 := m.SchedulingSpec.MarshalTo(dAtA[i:])
		if err70 != nil {
			return 0, err70
		}
		i += n70
	}
	if len(m.PodSpec) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.PodSpec)))
		i += copy(dAtA[i:], m.PodSpec)
	}
	if m.HashtreeSpec != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.HashtreeSpec.Size()))
		n71, err71 := m.HashtreeSpec.MarshalTo(dAtA[i:])
		if err71 != nil {
			return 0, err71
		}
		i += n71
	}
	if m.LastJobState != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.LastJobState))
	}
	if len(m.PodPatch) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.PodPatch)))
		i += copy(dAtA[i:], m.PodPatch)
	}
	if m.Spout != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Spout.Size()))
		n72, err72 := m.Spout.MarshalTo(dAtA[i:])
		if err72 != nil {
			return 0, err72
		}
		i += n72
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PipelineInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PipelineInfos) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PipelineInfo) > 0 {
		for _, msg := range m.PipelineInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateJobRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pipeline != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n73, err73 := m.Pipeline.MarshalTo(dAtA[i:])
		if err73 != nil {
			return 0, err73
		}
		i += n73
	}
	if m.OutputCommit != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.OutputCommit.Size()))
		n74, err74 := m.OutputCommit.MarshalTo(dAtA[i:])
		if err74 != nil {
			return 0, err74
		}
		i += n74
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InspectJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectJobRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Job != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Job.Size()))
		n75, err75 := m.Job.MarshalTo(dAtA[i:])
		if err75 != nil {
			return 0, err75
		}
		i += n75
	}
	if m.BlockState {
		dAtA[i] = 0x10
		i++
		if m.BlockState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OutputCommit != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.OutputCommit.Size()))
		n76, err76 := m.OutputCommit.MarshalTo(dAtA[i:])
		if err76 != nil {
			return 0, err76
		}
		i += n76
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListJobRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pipeline != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n77, err77 := m.Pipeline.MarshalTo(dAtA[i:])
		if err77 != nil {
			return 0, err77
		}
		i += n77
	}
	if len(m.InputCommit) > 0 {
		for _, msg := range m.InputCommit {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.OutputCommit != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.OutputCommit.Size()))
		n78, err78 := m.OutputCommit.MarshalTo(dAtA[i:])
		if err78 != nil {
			return 0, err78
		}
		i += n78
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FlushJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlushJobRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Commits) > 0 {
		for _, msg := range m.Commits {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ToPipelines) > 0 {
		for _, msg := range m.ToPipelines {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DeleteJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteJobRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Job != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Job.Size()))
		n79, err79 := m.Job.MarshalTo(dAtA[i:])
		if err79 != nil {
			return 0, err79
		}
		i += n79
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StopJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopJobRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Job != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Job.Size()))
		n80, err80 := m.Job.MarshalTo(dAtA[i:])
		if err80 != nil {
			return 0, err80
		}
		i += n80
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetLogsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLogsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Job != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Job.Size()))
		n81, err81 := m.Job.MarshalTo(dAtA[i:])
		if err81 != nil {
			return 0, err81
		}
		i += n81
	}
	if m.Pipeline != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n82, err82 := m.Pipeline.MarshalTo(dAtA[i:])
		if err82 != nil {
			return 0, err82
		}
		i += n82
	}
	if len(m.DataFilters) > 0 {
		for _, s := range m.DataFilters {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Master {
		dAtA[i] = 0x28
		i++
		if m.Master {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Datum != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Datum.Size()))
		n83, err83 := m.Datum.MarshalTo(dAtA[i:])
		if err83 != nil {
			return 0, err83
		}
		i += n83
	}
	if m.Follow {
		dAtA[i] = 0x38
		i++
		if m.Follow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Tail != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Tail))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LogMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PipelineName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.PipelineName)))
		i += copy(dAtA[i:], m.PipelineName)
	}
	if len(m.JobID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.JobID)))
		i += copy(dAtA[i:], m.JobID)
	}
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x22
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Ts != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Ts.Size()))
		n84, err84 := m.Ts.MarshalTo(dAtA[i:])
		if err84 != nil {
			return 0, err84
		}
		i += n84
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if len(m.WorkerID) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.WorkerID)))
		i += copy(dAtA[i:], m.WorkerID)
	}
	if m.User {
		dAtA[i] = 0x40
		i++
		if m.User {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.DatumID) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.DatumID)))
		i += copy(dAtA[i:], m.DatumID)
	}
	if m.Master {
		dAtA[i] = 0x50
		i++
		if m.Master {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RestartDatumRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestartDatumRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Job != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Job.Size()))
		n85, err85 := m.Job.MarshalTo(dAtA[i:])
		if err85 != nil {
			return 0, err85
		}
		i += n85
	}
	if len(m.DataFilters) > 0 {
		for _, s := range m.DataFilters {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InspectDatumRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectDatumRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Datum != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Datum.Size()))
		n86, err86 := m.Datum.MarshalTo(dAtA[i:])
		if err86 != nil {
			return 0, err86
		}
		i += n86
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListDatumRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDatumRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Job != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Job.Size()))
		n87, err87 := m.Job.MarshalTo(dAtA[i:])
		if err87 != nil {
			return 0, err87
		}
		i += n87
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.PageSize))
	}
	if m.Page != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Page))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListDatumResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDatumResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DatumInfos) > 0 {
		for _, msg := range m.DatumInfos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TotalPages != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.TotalPages))
	}
	if m.Page != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Page))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListDatumStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDatumStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DatumInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DatumInfo.Size()))
		n88, err88 := m.DatumInfo.MarshalTo(dAtA[i:])
		if err88 != nil {
			return 0, err88
		}
		i += n88
	}
	if m.TotalPages != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.TotalPages))
	}
	if m.Page != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Page))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChunkSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChunkSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Number != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Number))
	}
	if m.SizeBytes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.SizeBytes))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SchedulingSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchedulingSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeSelector) > 0 {
		for k, _ := range m.NodeSelector {
			dAtA[i] = 0xa
			i++
			v := m.NodeSelector[k]
			mapSize := 1 + len(k) + sovPps(uint64(len(k))) + 1 + len(v) + sovPps(uint64(len(v)))
			i = encodeVarintPps(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPps(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintPps(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.PriorityClassName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.PriorityClassName)))
		i += copy(dAtA[i:], m.PriorityClassName)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreatePipelineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreatePipelineRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pipeline != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n89, err89 := m.Pipeline.MarshalTo(dAtA[i:])
		if err89 != nil {
			return 0, err89
		}
		i += n89
	}
	if m.Transform != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Transform.Size()))
		n90, err90 := m.Transform.MarshalTo(dAtA[i:])
		if err90 != nil {
			return 0, err90
		}
		i += n90
	}
	if m.Update {
		dAtA[i] = 0x28
		i++
		if m.Update {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ParallelismSpec != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ParallelismSpec.Size()))
		n91, err91 := m.ParallelismSpec.MarshalTo(dAtA[i:])
		if err91 != nil {
			return 0, err91
		}
		i += n91
	}
	if m.Egress != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Egress.Size()))
		n92, err92 := m.Egress.MarshalTo(dAtA[i:])
		if err92 != nil {
			return 0, err92
		}
		i += n92
	}
	if len(m.OutputBranch) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.OutputBranch)))
		i += copy(dAtA[i:], m.OutputBranch)
	}
	if m.ScaleDownThreshold != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ScaleDownThreshold.Size()))
		n93, err93 := m.ScaleDownThreshold.MarshalTo(dAtA[i:])
		if err93 != nil {
			return 0, err93
		}
		i += n93
	}
	if m.ResourceRequests != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ResourceRequests.Size()))
		n94, err94 := m.ResourceRequests.MarshalTo(dAtA[i:])
		if err94 != nil {
			return 0, err94
		}
		i += n94
	}
	if m.Input != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Input.Size()))
		n95, err95 := m.Input.MarshalTo(dAtA[i:])
		if err95 != nil {
			return 0, err95
		}
		i += n95
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.CacheSize) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.CacheSize)))
		i += copy(dAtA[i:], m.CacheSize)
	}
	if m.EnableStats {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.EnableStats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Reprocess {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		if m.Reprocess {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Batch {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.Batch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxQueueSize != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.MaxQueueSize))
	}
	if m.Service != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Service.Size()))
		n96, err96 := m.Service.MarshalTo(dAtA[i:])
		if err96 != nil {
			return 0, err96
		}
		i += n96
	}
	if m.ResourceLimits != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ResourceLimits.Size()))
		n97, err97 := m.ResourceLimits.MarshalTo(dAtA[i:])
		if err97 != nil {
			return 0, err97
		}
		i += n97
	}
	if m.ChunkSpec != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ChunkSpec.Size()))
		n98, err98 := m.ChunkSpec.MarshalTo(dAtA[i:])
		if err98 != nil {
			return 0, err98
		}
		i += n98
	}
	if m.DatumTimeout != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DatumTimeout.Size()))
		n99, err99 := m.DatumTimeout.MarshalTo(dAtA[i:])
		if err99 != nil {
			return 0, err99
		}
		i += n99
	}
	if m.JobTimeout != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.JobTimeout.Size()))
		n100, err100 := m.JobTimeout.MarshalTo(dAtA[i:])
		if err100 != nil {
			return 0, err100
		}
		i += n100
	}
	if len(m.Salt) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Salt)))
		i += copy(dAtA[i:], m.Salt)
	}
	if m.Standby {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		if m.Standby {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DatumTries != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DatumTries))
	}
	if m.SchedulingSpec != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.SchedulingSpec.Size()))
		n101, err101 := m.SchedulingSpec.MarshalTo(dAtA[i:])
		if err101 != nil {
			return 0, err101
		}
		i += n101
	}
	if len(m.PodSpec) > 0 {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.PodSpec)))
		i += copy(dAtA[i:], m.PodSpec)
	}
	if m.HashtreeSpec != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.HashtreeSpec.Size()))
		n102, err102 := m.HashtreeSpec.MarshalTo(dAtA[i:])
		if err102 != nil {
			return 0, err102
		}
		i += n102
	}
	if len(m.PodPatch) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.PodPatch)))
		i += copy(dAtA[i:], m.PodPatch)
	}
	if m.Spout != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Spout.Size()))
		n103, err103 := m.Spout.MarshalTo(dAtA[i:])
		if err103 != nil {
			return 0, err103
		}
		i += n103
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InspectPipelineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectPipelineRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pipeline != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n104, err104 := m.Pipeline.MarshalTo(dAtA[i:])
		if err104 != nil {
			return 0, err104
		}
		i += n104
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListPipelineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListPipelineRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DeletePipelineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeletePipelineRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pipeline != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n105, err105 := m.Pipeline.MarshalTo(dAtA[i:])
		if err105 != nil {
			return 0, err105
		}
		i += n105
	}
	if m.All {
		dAtA[i] = 0x20
		i++
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Force {
		dAtA[i] = 0x28
		i++
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StartPipelineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartPipelineRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pipeline != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n106, err106 := m.Pipeline.MarshalTo(dAtA[i:])
		if err106 != nil {
			return 0, err106
		}
		i += n106
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StopPipelineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopPipelineRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pipeline != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n107, err107 := m.Pipeline.MarshalTo(dAtA[i:])
		if err107 != nil {
			return 0, err107
		}
		i += n107
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RunPipelineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunPipelineRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pipeline != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n108, err108 := m.Pipeline.MarshalTo(dAtA[i:])
		if err108 != nil {
			return 0, err108
		}
		i += n108
	}
	if len(m.Provenance) > 0 {
		for _, msg := range m.Provenance {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.BranchProvenance) > 0 {
		for _, msg := range m.BranchProvenance {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GarbageCollectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GarbageCollectRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MemoryBytes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.MemoryBytes))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GarbageCollectResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GarbageCollectResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ActivateAuthRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivateAuthRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ActivateAuthResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivateAuthResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintPps(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Secret) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.MountPath)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.EnvVar)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Transform) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.Cmd) > 0 {
		for _, s := range m.Cmd {
			l = len(s)
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if len(m.Env) > 0 {
		for k, v := range m.Env {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPps(uint64(len(k))) + 1 + len(v) + sovPps(uint64(len(v)))
			n += mapEntrySize + 1 + sovPps(uint64(mapEntrySize))
		}
	}
	if len(m.Secrets) > 0 {
		for _, e := range m.Secrets {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if len(m.Stdin) > 0 {
		for _, s := range m.Stdin {
			l = len(s)
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if len(m.AcceptReturnCode) > 0 {
		l = 0
		for _, e := range m.AcceptReturnCode {
			l += sovPps(uint64(e))
		}
		n += 1 + sovPps(uint64(l)) + l
	}
	if m.Debug {
		n += 2
	}
	if len(m.ImagePullSecrets) > 0 {
		for _, s := range m.ImagePullSecrets {
			l = len(s)
			n += 1 + l + sovPps(uint64(l))
		}
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.WorkingDir)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Dockerfile)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.ErrCmd) > 0 {
		for _, s := range m.ErrCmd {
			l = len(s)
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if len(m.ErrStdin) > 0 {
		for _, s := range m.ErrStdin {
			l = len(s)
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Egress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Job) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Service) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InternalPort != 0 {
		n += 1 + sovPps(uint64(m.InternalPort))
	}
	if m.ExternalPort != 0 {
		n += 1 + sovPps(uint64(m.ExternalPort))
	}
	l = len(m.IP)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Spout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Overwrite {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AtomInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Repo)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Commit)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Glob)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Lazy {
		n += 2
	}
	if m.EmptyFiles {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PFSInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Repo)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Commit)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Glob)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Lazy {
		n += 2
	}
	if m.EmptyFiles {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CronInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Repo)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Commit)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Spec)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Overwrite {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GitInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Commit)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Input) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Atom != nil {
		l = m.Atom.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.Cross) > 0 {
		for _, e := range m.Cross {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if len(m.Union) > 0 {
		for _, e := range m.Union {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.Cron != nil {
		l = m.Cron.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Git != nil {
		l = m.Git.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Pfs != nil {
		l = m.Pfs.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JobInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Glob)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Lazy {
		n += 2
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ParallelismSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constant != 0 {
		n += 1 + sovPps(uint64(m.Constant))
	}
	if m.Coefficient != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HashtreeSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constant != 0 {
		n += 1 + sovPps(uint64(m.Constant))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InputFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Datum) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatumInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Datum != nil {
		l = m.Datum.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovPps(uint64(m.State))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.PfsState != nil {
		l = m.PfsState.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Aggregate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovPps(uint64(m.Count))
	}
	if m.Mean != 0 {
		n += 9
	}
	if m.Stddev != 0 {
		n += 9
	}
	if m.FifthPercentile != 0 {
		n += 9
	}
	if m.NinetyFifthPercentile != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProcessStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DownloadTime != nil {
		l = m.DownloadTime.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.ProcessTime != nil {
		l = m.ProcessTime.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.UploadTime != nil {
		l = m.UploadTime.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.DownloadBytes != 0 {
		n += 1 + sovPps(uint64(m.DownloadBytes))
	}
	if m.UploadBytes != 0 {
		n += 1 + sovPps(uint64(m.UploadBytes))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AggregateProcessStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DownloadTime != nil {
		l = m.DownloadTime.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.ProcessTime != nil {
		l = m.ProcessTime.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.UploadTime != nil {
		l = m.UploadTime.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.DownloadBytes != nil {
		l = m.DownloadBytes.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.UploadBytes != nil {
		l = m.UploadBytes.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkerStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WorkerID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.JobID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.Started != nil {
		l = m.Started.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.QueueSize != 0 {
		n += 1 + sovPps(uint64(m.QueueSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourceSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cpu != 0 {
		n += 5
	}
	l = len(m.Memory)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Disk)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Gpu != nil {
		l = m.Gpu.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GPUSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Number != 0 {
		n += 1 + sovPps(uint64(m.Number))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EtcdJobInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.OutputCommit != nil {
		l = m.OutputCommit.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Restart != 0 {
		n += 1 + sovPps(uint64(m.Restart))
	}
	if m.DataProcessed != 0 {
		n += 1 + sovPps(uint64(m.DataProcessed))
	}
	if m.DataSkipped != 0 {
		n += 1 + sovPps(uint64(m.DataSkipped))
	}
	if m.DataTotal != 0 {
		n += 1 + sovPps(uint64(m.DataTotal))
	}
	if m.DataFailed != 0 {
		n += 1 + sovPps(uint64(m.DataFailed))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.StatsCommit != nil {
		l = m.StatsCommit.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovPps(uint64(m.State))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Started != nil {
		l = m.Started.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Finished != nil {
		l = m.Finished.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.DataRecovered != 0 {
		n += 1 + sovPps(uint64(m.DataRecovered))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JobInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Transform != nil {
		l = m.Transform.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.ParentJob != nil {
		l = m.ParentJob.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Started != nil {
		l = m.Started.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Finished != nil {
		l = m.Finished.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.OutputCommit != nil {
		l = m.OutputCommit.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovPps(uint64(m.State))
	}
	if m.ParallelismSpec != nil {
		l = m.ParallelismSpec.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.PipelineVersion != 0 {
		n += 1 + sovPps(uint64(m.PipelineVersion))
	}
	if m.Service != nil {
		l = m.Service.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Egress != nil {
		l = m.Egress.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.OutputBranch)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.OutputRepo != nil {
		l = m.OutputRepo.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Restart != 0 {
		n += 2 + sovPps(uint64(m.Restart))
	}
	if m.DataProcessed != 0 {
		n += 2 + sovPps(uint64(m.DataProcessed))
	}
	if m.DataTotal != 0 {
		n += 2 + sovPps(uint64(m.DataTotal))
	}
	if len(m.WorkerStatus) > 0 {
		for _, e := range m.WorkerStatus {
			l = e.Size()
			n += 2 + l + sovPps(uint64(l))
		}
	}
	if m.ResourceRequests != nil {
		l = m.ResourceRequests.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Input != nil {
		l = m.Input.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.NewBranch != nil {
		l = m.NewBranch.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.StatsCommit != nil {
		l = m.StatsCommit.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.DataSkipped != 0 {
		n += 2 + sovPps(uint64(m.DataSkipped))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.EnableStats {
		n += 3
	}
	l = len(m.Salt)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Batch {
		n += 3
	}
	l = len(m.Reason)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.ResourceLimits != nil {
		l = m.ResourceLimits.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.ChunkSpec != nil {
		l = m.ChunkSpec.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.DatumTimeout != nil {
		l = m.DatumTimeout.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.JobTimeout != nil {
		l = m.JobTimeout.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.DataFailed != 0 {
		n += 2 + sovPps(uint64(m.DataFailed))
	}
	if m.DatumTries != 0 {
		n += 2 + sovPps(uint64(m.DatumTries))
	}
	if m.SchedulingSpec != nil {
		l = m.SchedulingSpec.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	l = len(m.PodSpec)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	l = len(m.PodPatch)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Spout != nil {
		l = m.Spout.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.DataRecovered != 0 {
		n += 2 + sovPps(uint64(m.DataRecovered))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Worker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovPps(uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JobInfos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.JobInfo) > 0 {
		for _, e := range m.JobInfo {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Pipeline) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PipelineInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Glob)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Lazy {
		n += 2
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EtcdPipelineInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovPps(uint64(m.State))
	}
	if m.SpecCommit != nil {
		l = m.SpecCommit.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.JobCounts) > 0 {
		for k, v := range m.JobCounts {
			_ = k
			_ = v
			mapEntrySize := 1 + sovPps(uint64(k)) + 1 + sovPps(uint64(v))
			n += mapEntrySize + 1 + sovPps(uint64(mapEntrySize))
		}
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.AuthToken)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.LastJobState != 0 {
		n += 1 + sovPps(uint64(m.LastJobState))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PipelineInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Transform != nil {
		l = m.Transform.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovPps(uint64(m.State))
	}
	l = len(m.RecentError)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.JobCounts) > 0 {
		for k, v := range m.JobCounts {
			_ = k
			_ = v
			mapEntrySize := 1 + sovPps(uint64(k)) + 1 + sovPps(uint64(v))
			n += mapEntrySize + 1 + sovPps(uint64(mapEntrySize))
		}
	}
	if m.ParallelismSpec != nil {
		l = m.ParallelismSpec.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovPps(uint64(m.Version))
	}
	if m.Egress != nil {
		l = m.Egress.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.OutputBranch)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.ScaleDownThreshold != nil {
		l = m.ScaleDownThreshold.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.ResourceRequests != nil {
		l = m.ResourceRequests.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Input != nil {
		l = m.Input.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	l = len(m.CacheSize)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.EnableStats {
		n += 3
	}
	l = len(m.Salt)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Batch {
		n += 3
	}
	l = len(m.Reason)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.MaxQueueSize != 0 {
		n += 2 + sovPps(uint64(m.MaxQueueSize))
	}
	if m.Service != nil {
		l = m.Service.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.ResourceLimits != nil {
		l = m.ResourceLimits.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.ChunkSpec != nil {
		l = m.ChunkSpec.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.DatumTimeout != nil {
		l = m.DatumTimeout.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.JobTimeout != nil {
		l = m.JobTimeout.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	l = len(m.GithookURL)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.SpecCommit != nil {
		l = m.SpecCommit.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Standby {
		n += 3
	}
	if m.Stopped {
		n += 3
	}
	if m.DatumTries != 0 {
		n += 2 + sovPps(uint64(m.DatumTries))
	}
	if m.SchedulingSpec != nil {
		l = m.SchedulingSpec.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	l = len(m.PodSpec)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.HashtreeSpec != nil {
		l = m.HashtreeSpec.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.LastJobState != 0 {
		n += 2 + sovPps(uint64(m.LastJobState))
	}
	l = len(m.PodPatch)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Spout != nil {
		l = m.Spout.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PipelineInfos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PipelineInfo) > 0 {
		for _, e := range m.PipelineInfo {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateJobRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.OutputCommit != nil {
		l = m.OutputCommit.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InspectJobRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.BlockState {
		n += 2
	}
	if m.OutputCommit != nil {
		l = m.OutputCommit.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListJobRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.InputCommit) > 0 {
		for _, e := range m.InputCommit {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.OutputCommit != nil {
		l = m.OutputCommit.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlushJobRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Commits) > 0 {
		for _, e := range m.Commits {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if len(m.ToPipelines) > 0 {
		for _, e := range m.ToPipelines {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteJobRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StopJobRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetLogsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.DataFilters) > 0 {
		for _, s := range m.DataFilters {
			l = len(s)
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.Master {
		n += 2
	}
	if m.Datum != nil {
		l = m.Datum.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Follow {
		n += 2
	}
	if m.Tail != 0 {
		n += 1 + sovPps(uint64(m.Tail))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LogMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PipelineName)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.JobID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.Ts != nil {
		l = m.Ts.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.WorkerID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.User {
		n += 2
	}
	l = len(m.DatumID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Master {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RestartDatumRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.DataFilters) > 0 {
		for _, s := range m.DataFilters {
			l = len(s)
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InspectDatumRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Datum != nil {
		l = m.Datum.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListDatumRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.PageSize != 0 {
		n += 1 + sovPps(uint64(m.PageSize))
	}
	if m.Page != 0 {
		n += 1 + sovPps(uint64(m.Page))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListDatumResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DatumInfos) > 0 {
		for _, e := range m.DatumInfos {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.TotalPages != 0 {
		n += 1 + sovPps(uint64(m.TotalPages))
	}
	if m.Page != 0 {
		n += 1 + sovPps(uint64(m.Page))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListDatumStreamResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatumInfo != nil {
		l = m.DatumInfo.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.TotalPages != 0 {
		n += 1 + sovPps(uint64(m.TotalPages))
	}
	if m.Page != 0 {
		n += 1 + sovPps(uint64(m.Page))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChunkSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Number != 0 {
		n += 1 + sovPps(uint64(m.Number))
	}
	if m.SizeBytes != 0 {
		n += 1 + sovPps(uint64(m.SizeBytes))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SchedulingSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NodeSelector) > 0 {
		for k, v := range m.NodeSelector {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPps(uint64(len(k))) + 1 + len(v) + sovPps(uint64(len(v)))
			n += mapEntrySize + 1 + sovPps(uint64(mapEntrySize))
		}
	}
	l = len(m.PriorityClassName)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreatePipelineRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Transform != nil {
		l = m.Transform.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Update {
		n += 2
	}
	if m.ParallelismSpec != nil {
		l = m.ParallelismSpec.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Egress != nil {
		l = m.Egress.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.OutputBranch)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.ScaleDownThreshold != nil {
		l = m.ScaleDownThreshold.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.ResourceRequests != nil {
		l = m.ResourceRequests.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Input != nil {
		l = m.Input.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.CacheSize)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.EnableStats {
		n += 3
	}
	if m.Reprocess {
		n += 3
	}
	if m.Batch {
		n += 3
	}
	if m.MaxQueueSize != 0 {
		n += 2 + sovPps(uint64(m.MaxQueueSize))
	}
	if m.Service != nil {
		l = m.Service.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.ResourceLimits != nil {
		l = m.ResourceLimits.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.ChunkSpec != nil {
		l = m.ChunkSpec.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.DatumTimeout != nil {
		l = m.DatumTimeout.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.JobTimeout != nil {
		l = m.JobTimeout.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	l = len(m.Salt)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Standby {
		n += 3
	}
	if m.DatumTries != 0 {
		n += 2 + sovPps(uint64(m.DatumTries))
	}
	if m.SchedulingSpec != nil {
		l = m.SchedulingSpec.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	l = len(m.PodSpec)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.HashtreeSpec != nil {
		l = m.HashtreeSpec.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	l = len(m.PodPatch)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Spout != nil {
		l = m.Spout.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InspectPipelineRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListPipelineRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeletePipelineRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.All {
		n += 2
	}
	if m.Force {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StartPipelineRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StopPipelineRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RunPipelineRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.Provenance) > 0 {
		for _, e := range m.Provenance {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if len(m.BranchProvenance) > 0 {
		for _, e := range m.BranchProvenance {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GarbageCollectRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemoryBytes != 0 {
		n += 1 + sovPps(uint64(m.MemoryBytes))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GarbageCollectResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActivateAuthRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActivateAuthResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPps(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPps(x uint64) (n int) {
	return sovPps(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Secret) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Secret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Secret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MountPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvVar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnvVar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transform) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transform: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transform: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cmd = append(m.Cmd, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Env == nil {
				m.Env = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPps
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPps
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPps
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPps
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthPps
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPps(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPps
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Env[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secrets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secrets = append(m.Secrets, &Secret{})
			if err := m.Secrets[len(m.Secrets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stdin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stdin = append(m.Stdin, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPps
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AcceptReturnCode = append(m.AcceptReturnCode, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPps
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPps
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPps
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AcceptReturnCode) == 0 {
					m.AcceptReturnCode = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AcceptReturnCode = append(m.AcceptReturnCode, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptReturnCode", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Debug = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePullSecrets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImagePullSecrets = append(m.ImagePullSecrets, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkingDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkingDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dockerfile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dockerfile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCmd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrCmd = append(m.ErrCmd, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrStdin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrStdin = append(m.ErrStdin, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Egress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Egress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Egress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Job) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Job: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Job: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Service) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Service: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Service: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalPort", wireType)
			}
			m.InternalPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InternalPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalPort", wireType)
			}
			m.ExternalPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Spout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Spout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Spout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Overwrite", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Overwrite = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AtomInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AtomInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AtomInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Glob", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Glob = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lazy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lazy = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmptyFiles", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EmptyFiles = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PFSInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PFSInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PFSInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Glob", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Glob = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lazy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lazy = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmptyFiles", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EmptyFiles = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CronInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CronInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CronInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spec = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &types.Timestamp{}
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Overwrite", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Overwrite = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GitInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GitInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GitInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Input) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Input: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Input: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Atom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Atom == nil {
				m.Atom = &AtomInput{}
			}
			if err := m.Atom.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cross", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cross = append(m.Cross, &Input{})
			if err := m.Cross[len(m.Cross)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Union", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Union = append(m.Union, &Input{})
			if err := m.Union[len(m.Union)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cron", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cron == nil {
				m.Cron = &CronInput{}
			}
			if err := m.Cron.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Git", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Git == nil {
				m.Git = &GitInput{}
			}
			if err := m.Git.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pfs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pfs == nil {
				m.Pfs = &PFSInput{}
			}
			if err := m.Pfs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &pfs.Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Glob", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Glob = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lazy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lazy = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParallelismSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParallelismSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParallelismSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constant", wireType)
			}
			m.Constant = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constant |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coefficient", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Coefficient = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HashtreeSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HashtreeSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HashtreeSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constant", wireType)
			}
			m.Constant = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constant |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Datum) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Datum: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Datum: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatumInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatumInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatumInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Datum == nil {
				m.Datum = &Datum{}
			}
			if err := m.Datum.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= DatumState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &ProcessStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PfsState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PfsState == nil {
				m.PfsState = &pfs.File{}
			}
			if err := m.PfsState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &pfs.FileInfo{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Aggregate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Aggregate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Aggregate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mean", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Mean = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stddev", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Stddev = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FifthPercentile", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FifthPercentile = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field NinetyFifthPercentile", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.NinetyFifthPercentile = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DownloadTime == nil {
				m.DownloadTime = &types.Duration{}
			}
			if err := m.DownloadTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProcessTime == nil {
				m.ProcessTime = &types.Duration{}
			}
			if err := m.ProcessTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UploadTime == nil {
				m.UploadTime = &types.Duration{}
			}
			if err := m.UploadTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadBytes", wireType)
			}
			m.DownloadBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownloadBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadBytes", wireType)
			}
			m.UploadBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AggregateProcessStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AggregateProcessStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AggregateProcessStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DownloadTime == nil {
				m.DownloadTime = &Aggregate{}
			}
			if err := m.DownloadTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProcessTime == nil {
				m.ProcessTime = &Aggregate{}
			}
			if err := m.ProcessTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UploadTime == nil {
				m.UploadTime = &Aggregate{}
			}
			if err := m.UploadTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DownloadBytes == nil {
				m.DownloadBytes = &Aggregate{}
			}
			if err := m.DownloadBytes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UploadBytes == nil {
				m.UploadBytes = &Aggregate{}
			}
			if err := m.UploadBytes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkerStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &InputFile{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Started == nil {
				m.Started = &types.Timestamp{}
			}
			if err := m.Started.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &ProcessStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueSize", wireType)
			}
			m.QueueSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueueSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Cpu = float32(math.Float32frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memory = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disk", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Disk = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gpu == nil {
				m.Gpu = &GPUSpec{}
			}
			if err := m.Gpu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GPUSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPUSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPUSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EtcdJobInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EtcdJobInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EtcdJobInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputCommit == nil {
				m.OutputCommit = &pfs.Commit{}
			}
			if err := m.OutputCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Restart", wireType)
			}
			m.Restart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Restart |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataProcessed", wireType)
			}
			m.DataProcessed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataProcessed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSkipped", wireType)
			}
			m.DataSkipped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSkipped |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTotal", wireType)
			}
			m.DataTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataTotal |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFailed", wireType)
			}
			m.DataFailed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataFailed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &ProcessStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StatsCommit == nil {
				m.StatsCommit = &pfs.Commit{}
			}
			if err := m.StatsCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= JobState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Started == nil {
				m.Started = &types.Timestamp{}
			}
			if err := m.Started.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Finished == nil {
				m.Finished = &types.Timestamp{}
			}
			if err := m.Finished.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataRecovered", wireType)
			}
			m.DataRecovered = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataRecovered |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transform", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transform == nil {
				m.Transform = &Transform{}
			}
			if err := m.Transform.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParentJob == nil {
				m.ParentJob = &Job{}
			}
			if err := m.ParentJob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Started == nil {
				m.Started = &types.Timestamp{}
			}
			if err := m.Started.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Finished == nil {
				m.Finished = &types.Timestamp{}
			}
			if err := m.Finished.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputCommit == nil {
				m.OutputCommit = &pfs.Commit{}
			}
			if err := m.OutputCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= JobState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParallelismSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParallelismSpec == nil {
				m.ParallelismSpec = &ParallelismSpec{}
			}
			if err := m.ParallelismSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineVersion", wireType)
			}
			m.PipelineVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PipelineVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Service == nil {
				m.Service = &Service{}
			}
			if err := m.Service.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Egress == nil {
				m.Egress = &Egress{}
			}
			if err := m.Egress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputBranch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputBranch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputRepo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputRepo == nil {
				m.OutputRepo = &pfs.Repo{}
			}
			if err := m.OutputRepo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Restart", wireType)
			}
			m.Restart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Restart |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataProcessed", wireType)
			}
			m.DataProcessed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataProcessed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTotal", wireType)
			}
			m.DataTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataTotal |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkerStatus = append(m.WorkerStatus, &WorkerStatus{})
			if err := m.WorkerStatus[len(m.WorkerStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceRequests == nil {
				m.ResourceRequests = &ResourceSpec{}
			}
			if err := m.ResourceRequests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Input == nil {
				m.Input = &Input{}
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewBranch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewBranch == nil {
				m.NewBranch = &pfs.BranchInfo{}
			}
			if err := m.NewBranch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StatsCommit == nil {
				m.StatsCommit = &pfs.Commit{}
			}
			if err := m.StatsCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSkipped", wireType)
			}
			m.DataSkipped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSkipped |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &ProcessStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableStats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableStats = bool(v != 0)
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Batch = bool(v != 0)
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceLimits == nil {
				m.ResourceLimits = &ResourceSpec{}
			}
			if err := m.ResourceLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChunkSpec == nil {
				m.ChunkSpec = &ChunkSpec{}
			}
			if err := m.ChunkSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DatumTimeout == nil {
				m.DatumTimeout = &types.Duration{}
			}
			if err := m.DatumTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobTimeout == nil {
				m.JobTimeout = &types.Duration{}
			}
			if err := m.JobTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFailed", wireType)
			}
			m.DataFailed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataFailed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumTries", wireType)
			}
			m.DatumTries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatumTries |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchedulingSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SchedulingSpec == nil {
				m.SchedulingSpec = &SchedulingSpec{}
			}
			if err := m.SchedulingSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodSpec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodSpec = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodPatch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodPatch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spout == nil {
				m.Spout = &Spout{}
			}
			if err := m.Spout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataRecovered", wireType)
			}
			m.DataRecovered = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataRecovered |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Worker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Worker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Worker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= WorkerState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobInfo = append(m.JobInfo, &JobInfo{})
			if err := m.JobInfo[len(m.JobInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pipeline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pipeline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pipeline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PipelineInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PipelineInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PipelineInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &pfs.Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Glob", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Glob = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lazy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lazy = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &pfs.Commit{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EtcdPipelineInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EtcdPipelineInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EtcdPipelineInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= PipelineState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpecCommit == nil {
				m.SpecCommit = &pfs.Commit{}
			}
			if err := m.SpecCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobCounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobCounts == nil {
				m.JobCounts = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPps
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPps(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPps
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.JobCounts[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastJobState", wireType)
			}
			m.LastJobState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastJobState |= JobState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PipelineInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PipelineInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PipelineInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transform", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transform == nil {
				m.Transform = &Transform{}
			}
			if err := m.Transform.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= PipelineState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecentError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecentError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobCounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobCounts == nil {
				m.JobCounts = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPps
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPps(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPps
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.JobCounts[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParallelismSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParallelismSpec == nil {
				m.ParallelismSpec = &ParallelismSpec{}
			}
			if err := m.ParallelismSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Egress == nil {
				m.Egress = &Egress{}
			}
			if err := m.Egress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputBranch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputBranch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScaleDownThreshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScaleDownThreshold == nil {
				m.ScaleDownThreshold = &types.Duration{}
			}
			if err := m.ScaleDownThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceRequests == nil {
				m.ResourceRequests = &ResourceSpec{}
			}
			if err := m.ResourceRequests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Input == nil {
				m.Input = &Input{}
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheSize = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableStats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableStats = bool(v != 0)
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Batch = bool(v != 0)
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxQueueSize", wireType)
			}
			m.MaxQueueSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxQueueSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Service == nil {
				m.Service = &Service{}
			}
			if err := m.Service.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceLimits == nil {
				m.ResourceLimits = &ResourceSpec{}
			}
			if err := m.ResourceLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChunkSpec == nil {
				m.ChunkSpec = &ChunkSpec{}
			}
			if err := m.ChunkSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DatumTimeout == nil {
				m.DatumTimeout = &types.Duration{}
			}
			if err := m.DatumTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobTimeout == nil {
				m.JobTimeout = &types.Duration{}
			}
			if err := m.JobTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GithookURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GithookURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpecCommit == nil {
				m.SpecCommit = &pfs.Commit{}
			}
			if err := m.SpecCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Standby", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Standby = bool(v != 0)
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stopped", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stopped = bool(v != 0)
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumTries", wireType)
			}
			m.DatumTries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatumTries |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchedulingSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SchedulingSpec == nil {
				m.SchedulingSpec = &SchedulingSpec{}
			}
			if err := m.SchedulingSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodSpec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodSpec = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashtreeSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HashtreeSpec == nil {
				m.HashtreeSpec = &HashtreeSpec{}
			}
			if err := m.HashtreeSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastJobState", wireType)
			}
			m.LastJobState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastJobState |= JobState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodPatch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodPatch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spout == nil {
				m.Spout = &Spout{}
			}
			if err := m.Spout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PipelineInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PipelineInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PipelineInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PipelineInfo = append(m.PipelineInfo, &PipelineInfo{})
			if err := m.PipelineInfo[len(m.PipelineInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputCommit == nil {
				m.OutputCommit = &pfs.Commit{}
			}
			if err := m.OutputCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BlockState = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputCommit == nil {
				m.OutputCommit = &pfs.Commit{}
			}
			if err := m.OutputCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputCommit = append(m.InputCommit, &pfs.Commit{})
			if err := m.InputCommit[len(m.InputCommit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputCommit == nil {
				m.OutputCommit = &pfs.Commit{}
			}
			if err := m.OutputCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlushJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlushJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlushJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commits = append(m.Commits, &pfs.Commit{})
			if err := m.Commits[len(m.Commits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToPipelines", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToPipelines = append(m.ToPipelines, &Pipeline{})
			if err := m.ToPipelines[len(m.ToPipelines)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLogsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLogsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLogsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFilters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataFilters = append(m.DataFilters, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Master", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Master = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Datum == nil {
				m.Datum = &Datum{}
			}
			if err := m.Datum.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Follow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Follow = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tail", wireType)
			}
			m.Tail = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tail |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PipelineName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &InputFile{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ts == nil {
				m.Ts = &types.Timestamp{}
			}
			if err := m.Ts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.User = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatumID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Master", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Master = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestartDatumRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestartDatumRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestartDatumRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFilters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataFilters = append(m.DataFilters, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectDatumRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectDatumRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectDatumRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Datum == nil {
				m.Datum = &Datum{}
			}
			if err := m.Datum.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDatumRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListDatumRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListDatumRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDatumResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListDatumResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListDatumResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatumInfos = append(m.DatumInfos, &DatumInfo{})
			if err := m.DatumInfos[len(m.DatumInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPages", wireType)
			}
			m.TotalPages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalPages |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDatumStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListDatumStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListDatumStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DatumInfo == nil {
				m.DatumInfo = &DatumInfo{}
			}
			if err := m.DatumInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPages", wireType)
			}
			m.TotalPages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalPages |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChunkSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChunkSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChunkSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchedulingSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchedulingSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchedulingSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeSelector == nil {
				m.NodeSelector = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPps
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPps
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPps
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPps
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthPps
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPps(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPps
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeSelector[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriorityClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriorityClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreatePipelineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreatePipelineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreatePipelineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transform", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transform == nil {
				m.Transform = &Transform{}
			}
			if err := m.Transform.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Update = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParallelismSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParallelismSpec == nil {
				m.ParallelismSpec = &ParallelismSpec{}
			}
			if err := m.ParallelismSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Egress == nil {
				m.Egress = &Egress{}
			}
			if err := m.Egress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputBranch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputBranch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScaleDownThreshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScaleDownThreshold == nil {
				m.ScaleDownThreshold = &types.Duration{}
			}
			if err := m.ScaleDownThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceRequests == nil {
				m.ResourceRequests = &ResourceSpec{}
			}
			if err := m.ResourceRequests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Input == nil {
				m.Input = &Input{}
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheSize = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableStats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableStats = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reprocess", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reprocess = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Batch = bool(v != 0)
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxQueueSize", wireType)
			}
			m.MaxQueueSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxQueueSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Service == nil {
				m.Service = &Service{}
			}
			if err := m.Service.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceLimits == nil {
				m.ResourceLimits = &ResourceSpec{}
			}
			if err := m.ResourceLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChunkSpec == nil {
				m.ChunkSpec = &ChunkSpec{}
			}
			if err := m.ChunkSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DatumTimeout == nil {
				m.DatumTimeout = &types.Duration{}
			}
			if err := m.DatumTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobTimeout == nil {
				m.JobTimeout = &types.Duration{}
			}
			if err := m.JobTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Standby", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Standby = bool(v != 0)
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumTries", wireType)
			}
			m.DatumTries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatumTries |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchedulingSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SchedulingSpec == nil {
				m.SchedulingSpec = &SchedulingSpec{}
			}
			if err := m.SchedulingSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodSpec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodSpec = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashtreeSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HashtreeSpec == nil {
				m.HashtreeSpec = &HashtreeSpec{}
			}
			if err := m.HashtreeSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodPatch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodPatch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spout == nil {
				m.Spout = &Spout{}
			}
			if err := m.Spout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectPipelineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectPipelineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectPipelineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListPipelineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListPipelineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListPipelineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeletePipelineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeletePipelineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeletePipelineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartPipelineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartPipelineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartPipelineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopPipelineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopPipelineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopPipelineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunPipelineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunPipelineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunPipelineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provenance = append(m.Provenance, &pfs.Commit{})
			if err := m.Provenance[len(m.Provenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BranchProvenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BranchProvenance = append(m.BranchProvenance, &pfs.Branch{})
			if err := m.BranchProvenance[len(m.BranchProvenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GarbageCollectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GarbageCollectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GarbageCollectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryBytes", wireType)
			}
			m.MemoryBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GarbageCollectResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GarbageCollectResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GarbageCollectResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivateAuthRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivateAuthRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivateAuthRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivateAuthResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivateAuthResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivateAuthResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPps(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPps
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPps
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPps
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPps
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthPps
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPps
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPps(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthPps
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPps = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPps   = fmt.Errorf("proto: integer overflow")
)
